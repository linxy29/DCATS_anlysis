---
title: "Test dcats_GLM"
author: "Xinyi Lin"
date: "7/20/2021"
output: html_document
---

This file is used to test the function in `DCATS` package.

```{r}
library(DCATS)
data("simulation")
knn_mat = knn_simMat(simulation$knnGraphs, simulation$labels)
sim_count = rbind(simulation$numb_cond1, simulation$numb_cond2)
sim_design = data.frame(condition = c("c1", "c1", "c2"))
res = dcats_GLM(as.matrix(sim_count), sim_design, similarity_mat = knn_mat[colnames(sim_count),])
print(res$LRT_pvals)
```

```{r}
count_mat = sim_count
design_mat = sim_design
similarity_mat = knn_mat[colnames(sim_count),]
```

```{r}
coeffs <- matrix(NA, ncol(count_mat), ncol(design_mat))
coeffs_err <- matrix(NA, ncol(count_mat), ncol(design_mat))
LR_vals <- matrix(NA, ncol(count_mat), ncol(design_mat))
LRT_pvals <- matrix(NA, ncol(count_mat), ncol(design_mat))
pvals <- matrix(NA, ncol(count_mat), ncol(design_mat))
LRT_fdr <- matrix(NA, ncol(count_mat), ncol(design_mat))
if (is.null(colnames(count_mat))) 
  colnames(count_mat) <- paste0("cell_type_", seq(ncol(count_mat)))
if (is.null(colnames(design_mat))) 
  colnames(design_mat) <- paste0("factor_", seq(ncol(design_mat)))

rownames(LR_vals) <- rownames(LRT_pvals) <- rownames(pvals) <- rownames(LRT_fdr) <- rownames(coeffs) <- rownames(coeffs_err) <- colnames(count_mat)
colnames(LR_vals) <- colnames(LRT_pvals) <- colnames(pvals) <- colnames(LRT_fdr) <- colnames(coeffs) <- colnames(coeffs_err) <- colnames(design_mat)
count_use = count_mat
if (!is.null(similarity_mat)) {
  for (i in seq_len(nrow(count_mat))) {
    count_use[i, ] <- sum(count_mat[i, ]) * multinom_EM(count_mat[i, ], similarity_mat, verbose = FALSE)$mu
  }
  }
K <- ncol(count_mat)
if (is.null(pseudo_count)) {
  if (any(colMeans(count_mat) == 0)) {
    print(paste("Empty cell type exists in at least one conidtion;", 
                "adding replicate & condition specific pseudo count:"))
    count_use <- count_use + 1
  }
  }else {
  count_use = count_use + pseudo_count
  }
count_use = round(count_use)
n_samples = 1
for (k in seq_len(ncol(design_mat))) {
  sub_LR_val <- matrix(NA, n_samples, K)
  sub_coeffs_val <- matrix(NA, n_samples, K)
  sub_coeffs_err <- matrix(NA, n_samples, K)
  for (ir in seq_len(n_samples)) {
    idx <- seq(1, nrow(count_use), n_samples) + ir - 1
    for (m in seq_len(ncol(count_use))) {
      if (is.null(reference)) {
        df_use <- data.frame(n1 = count_use[, m], total = rowSums(count_use))[idx, ]
        df_use$ref_count = df_use$total - df_use$n1
        }
      else {
        df_use <- data.frame(n1 = count_use[, m], ref_count = count_use[, reference])[idx, ]}
      df_use <- cbind(df_use, design_mat)
      df_tmp <- df_use[!is.na(design_mat[, k]), ]
      if (base_model == "NULL" | ncol(design_mat) == 1) {
        formula_fm0 <- as.formula("cbind(n1, ref_count) ~ 1")
        formula_fm1 <- as.formula(paste0("cbind(n1, ref_count)", "~ 1+", colnames(design_mat)[k], sep = ""))}
      else if (base_model == "FULL") {
        fm0_right <- paste(colnames(design_mat)[-k], collapse = " + ")
        fm1_right <- paste(colnames(design_mat), collapse = " + ")
        formula_fm0 <- as.formula(paste0("cbind(n1, ref_count)", " ~ 1 + ", fm0_right, sep = ""))
        formula_fm1 <- as.formula(paste0("cbind(n1, ref_count)", " ~ 1 + ", fm1_right, sep = ""))}
      fm0 <- aod::betabin(formula_fm0, ~1, data = df_tmp, warnings = FALSE)
      fm1 <- aod::betabin(formula_fm1, ~1, data = df_tmp, warnings = FALSE)
      if (!is.null(fix_phi)) {
        fm0 <- aod::betabin(formula_fm0, ~1, data = df_tmp, warnings = FALSE, fixpar = list(fm0@nbpar, fix_phi))
        fm1 <- aod::betabin(formula_fm1, ~1, data = df_tmp, warnings = FALSE, fixpar = list(fm1@nbpar, fix_phi))
        }
      if (length(fm1@varparam) < 4 || is.na(fm1@varparam[2, 2])) {
        next
        }
      sub_LR_val[ir, m] <- fm0@dev - fm1@dev
      parID <- grep(colnames(design_mat)[k], names(fm1@param))
      if (length(parID) > 1) 
        stop("Please check the design matrix, make sure all factors are continous or categorical with only two levels.")
      sub_coeffs_val[ir, m] <- fm1@param[parID]
      if (is.null(fix_phi)) 
        sub_coeffs_err[ir, m] <- fm1@varparam[parID, parID]}
    }
  coeff_val_mean <- colMeans(sub_coeffs_val, na.rm = TRUE)
  if (is.null(fix_phi)) {
    if (is.null(n_samples) || is.null(similarity_mat) || n_samples == 1) {
      sub_coeff_err_pool <- colMeans(sub_coeffs_err^2, na.rm = TRUE)
      }else {
        sub_coeff_err_pool <- colMeans(sub_coeffs_err^2, 
                                       na.rm = TRUE) + matrixStats::colSds(sub_coeffs_val) + matrixStats::colSds(sub_coeffs_val)/n_samples}
            pvals[, k] <- pnorm(-abs(coeff_val_mean)/sqrt(sub_coeff_err_pool)) * 2
            coeffs_err[, k] <- sqrt(sub_coeff_err_pool)}
        LR_median = robustbase::colMedians(sub_LR_val, na.rm = TRUE)
        LR_vals[, k] <- LR_median
        LRT_pvals[, k] <- pchisq(LR_median, df = 1, lower.tail = FALSE, 
            log.p = FALSE)
        coeffs[, k] <- coeff_val_mean
    }
    LRT_fdr[, ] <- p.adjust(LRT_pvals, method = "fdr")
    res <- list(ceoffs = coeffs, coeffs_err = coeffs_err, LR_vals = LR_vals, 
        LRT_pvals = LRT_pvals, fdr = LRT_fdr)
    res
```

```{r}
X = count_mat[i, ]
simMM = similarity_mat
min_iter = 10
max_iter = 1000
logLik_threshold = 0.01
verbose = TRUE
```

```{r}
K = ncol(simMM)
    mu = sample(K)
    mu = mu/sum(mu)
    Z = matrix(NA, K, K)
    logLik_old <- logLik_new <- log(mu %*% simMM) %*% X
    if (verbose) {
        print(paste("Iteration 0 logLik:", round(logLik_new, 
            3)))
    }
    for (it in seq_len(max_iter)) {
        for (i in seq(K)) {
            for (j in seq(K)) {
                Z[i, j] = simMM[i, j] * mu[i]/sum(mu * simMM[, 
                  j])
            }
        }
        mu = c(Z %*% X)
        mu = mu/sum(mu)
        logLik_new <- log(mu %*% simMM) %*% X
        if (it > min_iter && logLik_new - logLik_old < logLik_threshold) {
            break
        }
        else {
            logLik_old <- logLik_new
        }
        if (verbose) {
            print(paste("Iteration", it, "logLik:", round(logLik_new, 
                3)))
        }
    }
    list(mu = mu, logLik = logLik_new, simMM = simMM, X = X, 
        X_prop = X/sum(X), predict_X_prop = mu %*% simMM)
```

