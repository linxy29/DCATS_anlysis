---
title: "Test dcats_GLM"
author: "Xinyi Lin"
date: "7/20/2021"
output: html_document
---

The function used: 

```{r}
dcats_GLM <- function(count_mat, design_mat, similarity_mat=NULL, n_samples=50, pseudo_count=NULL, intercept = TRUE,  base_model='NULL', fix_phi=NULL) {
  # Output matrices
  coeffs     <- matrix(NA, ncol(count_mat), ncol(design_mat))
  coeffs_err <- matrix(NA, ncol(count_mat), ncol(design_mat))
  LR_vals    <- matrix(NA, ncol(count_mat), ncol(design_mat))
  LRT_pvals  <- matrix(NA, ncol(count_mat), ncol(design_mat))
  pvals  <- matrix(NA, ncol(count_mat), ncol(design_mat))
  LRT_fdr    <- matrix(NA, ncol(count_mat), ncol(design_mat))
  
  # Check colnames
  if (is.null(colnames(count_mat)))
    colnames(count_mat) <- paste0('cell_type_', seq(ncol(count_mat)))
  if (is.null(colnames(design_mat)))
    colnames(design_mat) <- paste0('factor_', seq(ncol(design_mat)))
  
  # Add rownames and colnames
  rownames(LR_vals) <- rownames(LRT_pvals) <- rownames(pvals) <- rownames(LRT_fdr) <-
    rownames(coeffs) <- rownames(coeffs_err) <- colnames(count_mat)
  colnames(LR_vals) <- colnames(LRT_pvals) <- colnames(pvals) <- colnames(LRT_fdr) <-
    colnames(coeffs) <- colnames(coeffs_err) <- colnames(design_mat)
  
  
  ## using estimated the latent cell counts
  count_latent = count_mat
  if(!is.null(similarity_mat)) {
    for (i in seq_len(nrow(count_mat))) {
      count_latent[i, ] <- sum(count_mat[i, ]) *
        multinom_EM(count_mat[i, ], similarity_mat, verbose = FALSE)$mu
    }
  }
  
  K <- ncol(count_mat) ## number of cell types
  if (is.null(similarity_mat)) {
    n_samples <- 1
  }
  
  if (!is.null(n_samples) && !is.null(similarity_mat)) {
    count_use <- matrix(0, nrow(count_mat) * n_samples, K)
    for (i in seq_len(nrow(count_mat))) {
      idx <- seq((i - 1) * n_samples + 1, i * n_samples)
      for (j in seq_len(K)) {
        count_use[idx, ] <- (
          count_use[idx, ] + t(rmultinom(n_samples, count_latent[i, j], similarity_mat[j, ])))
      }
    }
  } else{
    count_use <- count_mat
  }
  
  # adding pseudo counts
  if (is.null(pseudo_count)) {
    if (any(colMeans(count_mat) == 0)) {
      print(paste("Empty cell type exists in at least one conidtion;",
                  "adding replicate & condition specific pseudo count:"))
      count_use <- count_use + 1
    }
  } else {
    count_use = count_use + pseudo_count
  }
  
  count_use = round(count_use)
  
  # Test each factor
  for (k in seq_len(ncol(design_mat))) {    ## for each factor
    sub_LR_val <- matrix(NA, n_samples, K)
    sub_coeffs_val <- matrix(NA, n_samples, K)
    sub_coeffs_err <- matrix(NA, n_samples, K)
    for (ir in seq_len(n_samples)) {          ## for each sampling
      for (m in seq_len(ncol(count_use))) {       ## for each cluster
        idx <- seq(1, nrow(count_use), n_samples) + ir - 1
        
        df_use <- data.frame(n1 = count_use[, m], total=rowSums(count_use))[idx,]
        df_use <- cbind(df_use, design_mat)
        df_tmp <- df_use[!is.na(design_mat[, k]), ]
        
        ## model fitting using betabin
        if (base_model=='NULL' | ncol(design_mat) == 1) {
          formula_fm0 <- as.formula('cbind(n1, total-n1) ~ 1')
        
          formula_fm1 <- as.formula(paste0('cbind(n1, total-n1)', '~ 1+', colnames(design_mat)[k], sep=''))
          #formula_fm1 <- as.formula(paste0('cbind(n1, total-n1)', ' ~ ', colnames(design_mat)[k], sep='')) # the same as the previous one
        } else if (base_model=='FULL') {
          fm0_right <- paste(colnames(design_mat)[-k], collapse = " + ")
          fm1_right <- paste(colnames(design_mat), collapse = " + ")
          if (isTRUE(intercept)){
            formula_fm0 <- as.formula(paste0('cbind(n1, total-n1)', ' ~ 1 + ', fm0_right, sep=''))
            formula_fm1 <- as.formula(paste0('cbind(n1, total-n1)', ' ~ 1 + ', fm1_right, sep=''))
          } else {
            formula_fm0 <- as.formula(paste0('cbind(n1, total-n1)', ' ~ ', fm0_right, sep=''))
            formula_fm1 <- as.formula(paste0('cbind(n1, total-n1)', ' ~ ', fm1_right, sep=''))
          }
        }
        fm0 <- aod::betabin(formula_fm0, ~ 1, data = df_tmp, warnings = FALSE)
        fm1 <- aod::betabin(formula_fm1, ~ 1, data = df_tmp, warnings = FALSE)
        if (!is.null(fix_phi)){
          fm0 <- aod::betabin(formula_fm0, ~ 1, data = df_tmp, warnings = FALSE, fixpar = list(fm0@nbpar, fix_phi))
          fm1 <- aod::betabin(formula_fm1, ~ 1, data = df_tmp, warnings = FALSE, fixpar = list(fm1@nbpar, fix_phi))
        }
        
        ## ignore the fitting if the hessian matrix is singular
        if (length(fm1@varparam) < 4 || is.na(fm1@varparam[2, 2])) {next}
        
        sub_LR_val[ir, m] <- 2*(fm1@logL - fm0@logL)
        parID <- grep(colnames(design_mat)[k], names(fm1@param))
        sub_coeffs_val[ir, m] <- fm1@param[parID]
        if(is.null(fix_phi))
          sub_coeffs_err[ir, m] <-fm1@varparam[parID, parID]
      }
    }
    
    coeff_val_mean <- colMeans(sub_coeffs_val, na.rm = TRUE)
    if (is.null(fix_phi)){
      ## averaging the estimation to get the final result
      if (is.null(n_samples) || is.null(similarity_mat) || n_samples == 1){
      sub_coeff_err_pool <- colMeans(sub_coeffs_err**2, na.rm = TRUE)
      } else {
        sub_coeff_err_pool <- colMeans(sub_coeffs_err**2, na.rm = TRUE) +
          matrixStats::colSds(sub_coeffs_val) +
          matrixStats::colSds(sub_coeffs_val) / n_samples
        }
      # p values with Ward test: https://en.wikipedia.org/wiki/Wald_test
      pvals[,k] <- pnorm(-abs(coeff_val_mean) / sqrt(sub_coeff_err_pool))  * 2
      coeffs_err[, k] <- sqrt(sub_coeff_err_pool)
    }
    
    
    LR_median = robustbase::colMedians(sub_LR_val, na.rm = TRUE)
    LR_vals[, k] <- LR_median
    LRT_pvals[, k] <- pchisq(LR_median, df=1, lower.tail = FALSE, log.p = FALSE)
    coeffs[, k] <- coeff_val_mean
  }
  
  # Return list
  LRT_fdr[,] <- p.adjust(LRT_pvals, method = 'fdr')
  res <- list('ceoffs'=coeffs, 'coeffs_err'=coeffs_err, 'pvals' = pvals, 'LR_vals'=LR_vals, 'LRT_pvals'=LRT_pvals, 'fdr'=LRT_fdr)
  res
}
```

```{r}
K <- 3
totals1 = c(100, 800, 1300, 600)
totals2 = c(250, 700, 1100)
diri_s1 = c(1/3, 1/3, 1/3) * 70
diri_s2 = c(1/3, 1/2, 1/6) * 70
simil_mat = simil_mat = matrix(c(1, 0, 0, 0, 0.7, 0.3, 0, 0.3, 0.7), ncol = 3)
sim_dat <- DCATS::simulator_base(totals1, totals2, diri_s1, diri_s2, simil_mat)
sim_count = rbind(sim_dat$numb_cond1, sim_dat$numb_cond2)
sim_design = data.frame(condition = c("g1", "g1", "g1", "g1", "g2", "g2", "g2"), gender = sample(c("Female", "Male"), 7, replace = TRUE))
count_mat = sim_count
design_mat = sim_design
```

Function to get global phi

```{r}
getPhi = function(count_mat, design_mat){
  K = ncol(count_mat)
  S = nrow(count_mat)
  total= rep(rowSums(count_mat), K)
  n1 = matrix(count_mat, ncol = 1)
  design_use = do.call("rbind", replicate(K, design_mat, simplify = FALSE))
  celltype_idx = matrix(0, S*K, K)
  for (type in 1:K) {
    celltype_idx[(1:S)+S*(type-1),type] = 1
  }
  df_use = data.frame(total, n1, design_use, celltype_idx[,-1])
  fm = aod::betabin(cbind(n1, total-n1) ~ ., ~ 1, data = df_use, warnings = FALSE) # make intercept as 0
  return(fm@random.param)
}
getPhi(sim_count, sim_design)
```


```{r, eval=FALSE}
## Test the useage of `fixpar`
library(aod)
data(dja)
betabin(cbind(y, n - y) ~ group, ~ 1, dja)
# heterogeneous phi
betabin(cbind(y, n - y) ~ group, ~ group, dja, control = list(maxit = 1000))
# phi fixed to zero in group TREAT
betabin(cbind(y, n - y) ~ group, ~ group, dja, fixpar = list(4, 0))
# glim without overdispersion
summary(glm(cbind(y, n - y) ~ group, family = binomial, data = dja))
# phi fixed to zero in both groups
betabin(cbind(y, n - y) ~ group, ~ group, dja, fixpar = list(c(3, 4), c(0, 0)))
```

```{r}
library(DCATS)
library(fastDummies)
library(tidyverse)
```

A very simple scenario

```{r}
K <- 3
totals1 = c(100, 800, 1300, 600)
totals2 = c(250, 700, 1100)
diri_s1 = c(1/3, 1/3, 1/3) * 70
diri_s2 = c(1/3, 1/2, 1/6) * 70
simil_mat = simil_mat = matrix(c(1, 0, 0, 0, 0.7, 0.3, 0, 0.3, 0.7), ncol = 3)
sim_dat <- DCATS::simulator_base(totals1, totals2, diri_s1, diri_s2, simil_mat)
sim_count = rbind(sim_dat$numb_cond1, sim_dat$numb_cond2)
sim_design = data.frame(condition = c("g1", "g1", "g1", "g1", "g2", "g2", "g2"), gender = sample(c("Female", "Male"), 7, replace = TRUE))
count_mat = sim_count
design_mat = sim_design
similarity_mat = simil_mat
fix_phi = concentration

set.seed(123)
## Using 1 factor vs NULL factor testing
dcats_GLM(count_mat = sim_count, design_mat = sim_design, similarity_mat = simil_mat)
## Using full factors vs n-1 factors testing with intercept term
dcats_GLM(count_mat = sim_count, design_mat = sim_design, similarity_mat = simil_mat, base_model='FULL')
## Using full factors vs n-1 factors testing without intercept term
dcats_GLM(count_mat = sim_count, design_mat = sim_design, similarity_mat = simil_mat, base_model='FULL', intercept = FALSE)
```

```{r}
data(orob2)
fm1 <- betabin(cbind(y, n - y) ~ seed, ~ 1, data = orob2)
fm1
fm1 <- betabin(cbind(y, n - y) ~ seed, ~ 1, data = orob2, fixpar = list(fm1@nbpar, 2))
fm1
fm2 <- betabin(cbind(y, n - y) ~ seed + root, ~ 1, data = orob2)
fm2
fm2 <- betabin(cbind(y, n - y) ~ seed + root, ~ 1, data = orob2, fixpar = list(fm2@nbpar, 2))
fm2
#fm3 <- betabin(cbind(y, n - y) ~ seed * root, ~ 1, data = orob2)
```


## Kaufmann2021

```{r}
pathSPC = "D:/Data"
Kaufmann2021 = read.delim(gzfile(str_c(pathSPC, "/DCATS/Kaufmann2021_metadata_per_cell.csv.gz")), sep = ",") %>% 
  janitor::clean_names() %>% 
  mutate_if(is.character, as.factor)
head(Kaufmann2021)
summary(Kaufmann2021)
Kaufmann2021 %>% group_by(group) %>% 
  summarise(donor = unique(donor)) %>% 
  summarise(n = n())
```

## treated vs untreated

should give positive result for T09&T06 -> wrong

```{r}
res_mat = Kaufmann2021 %>% filter(group == "MS1_nat" | group == "MS1") %>% 
  group_by(donor, cluster_names, sex, age_sampling, natalizumab_treatment) %>% 
  summarise(n = n()) %>% 
  pivot_wider(names_from = cluster_names, values_from = n) %>% 
  replace(is.na(.), 0) %>% 
  mutate(sample = str_c(donor, "_", natalizumab_treatment)) %>% 
  column_to_rownames("sample")
res_mat %>% print()
```

```{r}
count_mat = res_mat %>% dplyr::select(B01:T11) %>% 
  as.matrix()
design_mat = res_mat %>% dplyr::select(donor:natalizumab_treatment) %>% 
  dummy_cols(select_columns = "donor") %>% 
  dplyr::select(donor, age_sampling, natalizumab_treatment, str_c("donor_", res_mat$donor)) %>% 
  #select(donor, sex, age_sampling, natalizumab_treatment, str_c("donor_", res_mat$donor)) %>% 
  mutate(donor = str_c(donor, "_", natalizumab_treatment)) %>% 
  column_to_rownames("donor") %>% 
  janitor::clean_names() %>% 
  dplyr::select(-donor_hh_ox_31, -donor_hh_ox_23)
  
print(count_mat)
print(design_mat)

simil_mat = create_simMat(dim(count_mat)[2], confuse_rate=0.1)
res_GLM = dcats_GLM(count_mat = count_mat, design_mat = design_mat, similarity_mat = simil_mat, intercept = FALSE, base_model = "FULL")
## add fix_phi
res_GLM = dcats_GLM(count_mat = count_mat, design_mat = design_mat, similarity_mat = simil_mat, intercept = FALSE, base_model = "FULL", fix_phi = 0)
sig_GLM = ifelse(res_GLM$LRT_pvals < 0.05, "P", "N") 
print(sig_GLM)
print(res_GLM$LRT_pvals)
```

## test add fix phi for simulated data

```{r,message=FALSE,warning=FALSE}
library(splatter)
library(Seurat)
library(speckle)
library(DCATS)
library(ggplot2)
library(tidyverse)
library(MCMCpack)
library(pROC)
library(patchwork)
```

```{r}
source("functionsV2.r")
options(future.globals.maxSize = 20000 * 1024^2) # 20G memory
```

```{r}
theme_set(theme_classic()+
    theme(panel.border = element_blank(),
          legend.key = element_blank(),
          axis.ticks = element_blank(),
          panel.grid = element_blank(),
          panel.grid.minor = element_blank(), 
          panel.grid.major = element_blank(),
          panel.background = element_blank(),
          legend.background = element_blank(),
          plot.background = element_rect(fill = "transparent",colour = NA))+
      theme(axis.text=element_text(size=12),
        axis.title=element_text(size=14)))
```

```{r}
cluster_num = 3  # numbers of clusters
concentration = 70 # indicate how simulated proportion far away from true, the larger the closer
rep1 = 2
rep2 = 3
simulation_times = 50
simulation_size = 50
sample_size1 = 1000
sample_size2 = 2000
```

## Figure A

confusion matrix

![Figure A-1](./plot/PictureA-1.png)

#![Figure A-1](./plot/PictureA-1-5.png)

```{r, warning=FALSE, message=FALSE}
set.seed(123)

simulationDF_list = vector(mode = "list", length = simulation_times)
for (sim in 1:simulation_times) {
  simulationDF = data.frame()
  for (simsim in 1:simulation_size){
    ## create confusion matrix that is not uniformly distributed
    #simil_mat = get_similarity_mat(cluster_num, confuse_rate=0)
    simil_mat = matrix(c(1, 0, 0, 0, 0.7, 0.3, 0, 0.3, 0.7), ncol = 3)
    #simil_mat[5,5] = 0.6
    #simil_mat[5,3] = 0.4
    #simil_mat[3,5] = 0.4
    #simil_mat[3,3] = 0.6
    
    ## Data generation part
    totals1 = ceiling(runif(rep1, sample_size1, sample_size2))
    totals2 = ceiling(runif(rep2, sample_size1, sample_size2))
    diri_s1 = probC1 * concentration
    diri_s2 = probC2 * concentration
    sim_dat <- DCATS::simulator_base(totals1, totals2, diri_s1, diri_s2, simil_mat)
    numb_cond1 = as.matrix(sim_dat$numb_cond1)
    numb_cond2 = as.matrix(sim_dat$numb_cond2)
    
    ## Test part 1
    ### DCATS
    count_mat = rbind(numb_cond1, numb_cond2)
    design_df = data.frame(condition = c(rep("c1", dim(numb_cond1)[1]), rep("c2", dim(numb_cond2)[1])))
    dcats_res1 = dcats_GLM(count_mat, design_df)
    ### fisher
    fisher_pvals1 = getFisher(numb_cond1, numb_cond2)
    
    ## Bias Correction
    numb_cond1BC = numb_cond1
    numb_cond2BC = numb_cond2
    for (i in seq_len(nrow(numb_cond1))) {
      numb_cond1BC[i, ] <- sum(numb_cond1[i, ]) * multinom_EM(numb_cond1[i, ], simil_mat, verbose = FALSE)$mu
      numb_cond1BC[i, ] = ceiling(numb_cond1BC[i, ])}
    for (i in seq_len(nrow(numb_cond2))) {
      numb_cond2BC[i, ] <- sum(numb_cond2[i, ]) * multinom_EM(numb_cond2[i, ], simil_mat, verbose = FALSE)$mu
      numb_cond2BC[i, ] = ceiling(numb_cond2BC[i, ])}
    
    ## Test part 2
    ### DCATS
    count_mat = rbind(numb_cond1BC, numb_cond2BC)
    design_df = data.frame(condition = c(rep("c1", dim(numb_cond1)[1]), rep("c2", dim(numb_cond2)[1])))
    dcats_res2 = dcats_GLM(count_mat, design_df)
    ### fisher
    fisher_pvals2 = getFisher(numb_cond1BC, numb_cond2BC)
    
    all_res = data.frame(cluster = c("A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L")[1:cluster_num], truth = truthRes) %>%
      mutate(dcats_wtoBC = dcats_res1$LRT_pvals,
             fisher_wtoBC = fisher_pvals1,
             dcats_withBC = dcats_res2$LRT_pvals,
             fisher_withBC = fisher_pvals2)
    
    simulationDF = rbind(simulationDF, all_res)}
  simulationDF_list[[sim]] = simulationDF
}

#file_name = str_c("./data/simulationRES/replicates", as.character(rep1), "&", as.character(rep2), "_K", as.character(cluster_num), "_con", as.character(concentration), "_countSim.RData")
#save(simulationDF_list, file = file_name)

## send email after finishing
#sendEmail("Simulation is done!!")
```

```{r}
evaluationDF = data.frame()
len = length(simulationDF_list)
#for (j in 1:3){
for (j in 1:len){
  simulationDF = simulationDF_list[[j]] %>% na.omit()
  method = colnames(simulationDF)[3:dim(simulationDF)[2]]
  numb_mthd = length(method)
  sensitivity = rep(NA, numb_mthd)
  specificity = rep(NA, numb_mthd)
  mcc = rep(NA, numb_mthd)
  auc = rep(NA, numb_mthd)
  prauc = rep(NA, numb_mthd)
  F1 = rep(NA, numb_mthd)
  
  truth = simulationDF$truth
  for (i in 3:dim(simulationDF)[2]){
    pred = simulationDF[, i]
    pred_res = ifelse(pred < 0.05, "P", "N")
    TP <- sum(pred_res=="P"&truth=="P")
    TN <- sum(pred_res=="N"&truth=="N")
    FP <- sum(pred_res=="P"&truth=="N")
    FN <- sum(pred_res=="N"&truth=="P")
    truthN = TN + FP
    truthP = FN + TP
    predP = TP + FP
    predN = FN + TN
    sensitivity[i-2] = TP/truthP
    specificity[i-2] = TN/truthN
    mcc[i-2] = (TP*TN-FP*FN)/sqrt(predP*truthP*truthN*predN)
    auc[i-2] = getROC(truth, pred)$auc
    prauc[i-2] = getPRC(truth, pred)$prauc
    #print(getPRC(truth, pred)$eval)
    #print(prauc)
    F1 = 2*TP/(2*TP+FP+FN)
    
    res = data.frame(trial = as.character(j), method = method, sensitivity = sensitivity, specificity = specificity, mcc = mcc, auc = auc, prauc = prauc, F1 = F1)
    }
    evaluationDF = rbind(evaluationDF, res)
}
```

```{r}
evaluationDF %>% 
  tidyr::separate(method, c("method", "condition"), sep = "_") %>% 
  mutate(method = ifelse(method == "dcats", "DCATS", "Fisher"),
         condition = factor(condition, levels = c("wtoBC", "withBC"))) %>% 
  ggplot(aes(x = condition, y = prauc, color = method)) + geom_boxplot() +
  theme(axis.title.x = element_blank(),
        legend.position = "top") + 
  scale_color_manual(values=c("#F8766D", "#00BF7D"))
ggsave("C:/#Code/R/slides/image/RPG_discussion/dcats_result1.png", bg = "transparent")
```