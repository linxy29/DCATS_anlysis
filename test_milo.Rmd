---
title: "test_milo"
author: "Xinyi Lin"
date: "10/14/2021"
output: html_document
---

```{r}
library(miloR)
library(SingleCellExperiment)
library(scater)
library(scran)
library(tidyverse)
library(patchwork)
library(Seurat)
library(Matrix)
```

## real-world data 1 - Experiment 7

```{r}
exp7_data <- read.csv("./data/real_world/Exp7_Adam_2017/celltypelabels_Haber.txt", sep="") %>% 
  rownames_to_column("cell") %>% 
  separate(cell, c("batch", "barcode", "condition", "clusterRes"), sep = "_") 

head(exp7_data)
summary(exp7_data)

exp7_data %>% 
  group_by(batch, condition) %>% 
  summarise(n = n())
```

```{r}
geneExpM <- read.delim("./data/real_world/Exp7_Adam_2017/GSE92332_SalmHelm_UMIcounts.txt", header=TRUE)
seuratObj <- CreateSeuratObject(counts = geneExpM, project="Exp7")
exp7_sce <- as.SingleCellExperiment(seuratObj)
exp7_milo <- Milo(exp7_sce)
```

Milo part

```{r}
exp7_milo <- buildGraph(exp7_milo, k = 10, d = 30)
exp7_milo <- makeNhoods(exp7_milo, prop = 0.1, k = 10, d=30, refined = TRUE)
exp7_milo <- countCells(exp7_milo, meta.data = exp7_data, sample="condition")
head(nhoodCounts(exp7_milo))
```

```{r}
exp7_milo <- calcNhoodDistance(exp7_milo, d=30)
da_results <- testNhoods(exp7_milo, design = ~ condition, design.df = exp7_data)
```

## real-world data 5: Exp6-demuxlet

### store data

```{r}
exp6_clusterInfo = read.delim("./data/real_world/Exp6_Kang/GSE96583_batch2.total.tsne.df.tsv") %>% 
  dplyr::rename(clusterRes = cell, condition = stim) %>% 
  rownames_to_column("cell") %>% 
  filter(!is.na(clusterRes))
head(exp6_clusterInfo)
exp6_clusterInfo %>% group_by(condition, clusterRes) %>% 
  summarise(n = n())
## check whether exist duplicate barcode -> no
exp6_clusterInfo %>% 
  group_by(cell) %>% 
  summarise(n = n()) %>% 
  filter(n > 1)
```

```{r}
matrix1 = readMM(gzfile("./data/real_world/Exp6_Kang/GSM2560248_2.1.mtx.gz")) %>% 
  as.matrix()
matrix2 = readMM(gzfile("./data/real_world/Exp6_Kang/GSM2560249_2.2.mtx.gz")) %>% 
  as.matrix()
```

```{r}
data_dir1 = "./data/real_world/Exp6_Kang/GSM2560248"
list.files(data_dir1) # Should show barcodes.tsv, genes.tsv, and matrix.mtx
expression_matrix1 <- Read10X(data.dir = data_dir1)
seuratObj1 = CreateSeuratObject(counts = expression_matrix1)
seuratObj1 = AddMetaData(object = seuratObj1, metadata = rep("ctrl", dim(seuratObj1)[2]), col.name = 'sample')

data_dir2 = "./data/real_world/Exp6_Kang/GSM2560249"
list.files(data_dir2) # Should show barcodes.tsv, genes.tsv, and matrix.mtx
expression_matrix2 <- Read10X(data.dir = data_dir2)
seuratObj2 = CreateSeuratObject(counts = expression_matrix2)
seuratObj2 = AddMetaData(object = seuratObj2, metadata = rep("stim", dim(seuratObj2)[2]), col.name = 'sample')
```

```{r}
seuratObjL = c(sub1 = seuratObj1, sub2 = seuratObj2)
```

```{r}
anchors <- FindIntegrationAnchors(object.list = seuratObjL, dims = 1:30)
seurat_intg <- IntegrateData(anchorset = anchors, dims = 1:30)
seurat_intg <- ScaleData(seurat_intg)
seurat_intg <- RunPCA(seurat_intg, npcs = 30, verbose = FALSE)
```

```{r}
ctrl_repInfo <- read.delim("./data/real_world/Exp6_Kang/ye1.ctrl.8.10.sm.best")
stim_repInfo <- read.delim("./data/real_world/Exp6_Kang/ye2.stim.8.10.sm.best")
head(ctrl_repInfo)
head(stim_repInfo)

exp6_repInfo = rbind(ctrl_repInfo, stim_repInfo) %>% 
  dplyr::rename(cell = BARCODE, batch = BEST) %>% 
  filter(str_detect(batch, 'SNG')) %>% 
  dplyr::select(cell, batch)
head(exp6_repInfo)
```

```{r}
exp6_meta = data.frame(cell = str_replace(names(seurat_intg$orig.ident), "_[12]", "")) %>% 
  inner_join(exp6_clusterInfo) %>%
  inner_join(exp6_repInfo) %>% 
  mutate(batch = str_c(condition, batch)) %>% 
  dplyr::select(-cluster, -multiplets, -tsne1, -tsne2, -ind, -cell)

exp6_meta[cellID,]
```

```{r}
exp6_sce <- as.SingleCellExperiment(seurat_intg)
exp6_milo <- Milo(exp6_sce)
```

```{r}
exp6_milo <- buildGraph(exp6_milo, k = 10, d = 30)
exp6_milo <- makeNhoods(exp6_milo, prop = 0.1, k = 10, d=30, refined = TRUE)
exp6_milo <- countCells(exp6_milo, meta.data = seurat_intg@meta.data, sample="sample")
head(nhoodCounts(exp6_milo))
```

```{r}
exp7_milo <- calcNhoodDistance(exp7_milo, d=30)

da_results <- testNhoods(exp7_milo, design = ~ sample, design.df = seurat_intg@meta.data)
```

## Simulation

```{r}
integratedSamples = simulation$integratedSamples
getMilo = function(integratedSamples){
  # create object
  sceObj <- as.SingleCellExperiment(integratedSamples)
  milo <- Milo(sceObj)
  milo <- buildGraph(milo, k = 10, d = 30)
  milo <- makeNhoods(milo, prop = 0.1, k = 10, d=30, refined = TRUE)
  # get milo result
  milo <- countCells(milo, meta.data = data.frame(colData(milo)), sample="batch")
  if ("gender" %in% colnames(colData(milo))) {
    designDF <- data.frame(colData(milo))[,c("batch", "condition", "gender", "age")]
    designDF <- distinct(designDF)
    milo <- calcNhoodDistance(milo, d=30)
    rownames(designDF) <- designDF$batch
    da_condition <- testNhoods(milo, design = ~ age + gender + condition, design.df = designDF)
    da_gender <- testNhoods(milo, design = ~ age + condition + gender, design.df = designDF)
    da_age <- testNhoods(milo, design = ~ condition + gender + age, design.df = designDF)
    null_condition = testNhoods(milo, design = ~ condition, design.df = designDF)
    null_age = testNhoods(milo, design = ~ age, design.df = designDF)
    null_gender = testNhoods(milo, design = ~ gender, design.df = designDF)
    da_resultsL = list(da_condition = da_condition, da_gender = da_gender, da_age = da_age, null_condition = null_condition, null_age = null_age, null_gender = null_gender)
    da_resultsL <- lapply(X = da_resultsL, FUN = function(x) {
    x <- annotateNhoods(milo, x, coldata_col = "ident")
})
    da_results = rbind(da_resultsL$da_condition %>% mutate(detect = "condition_full"), da_resultsL$null_condition %>% mutate(detect = "condition_null"), da_resultsL$da_gender %>% mutate(detect = "gender_full"), da_resultsL$null_gender %>% mutate(detect = "gender_null"), da_resultsL$da_age %>% mutate(detect = "age_full"), da_resultsL$null_age %>% mutate(detect = "age_null"))
  } else {
    designDF <- data.frame(colData(milo))[,c("batch", "condition")]
    designDF <- distinct(designDF)
    milo <- calcNhoodDistance(milo, d=30)
    rownames(designDF) <- designDF$batch
    da_results <- testNhoods(milo, design = ~ condition, design.df = designDF)
    da_results <- annotateNhoods(milo, da_results, coldata_col = "ident")
    da_resultsL = "not_applicable"
  }
  counts <- nhoodCounts(milo)
  # get nhoods
  anno_vec <- colData(milo) %>% rownames()
  if (!is.factor(anno_vec)) {
    anno_vec <- factor(anno_vec, levels=unique(anno_vec))
  }
  
  ## Count occurrence of labels in each nhood
  n.levels <- length(levels(anno_vec))
  nhood_counts <- vapply(seq_len(ncol(nhoods(milo))), FUN=function(n)
    table(anno_vec[which(nhoods(milo)[,n]==1)]),FUN.VALUE=numeric(n.levels))
  colnames(nhood_counts) = str_c("hoods", 1:ncol(nhood_counts))
  select_nhood = nhood_counts[rowSums(nhood_counts) > 0,]
  nhoodsID = sapply(seq_len(nrow(select_nhood)), FUN = function(n)
    sample(colnames(select_nhood)[select_nhood[n,] != 0], size = 1))
  names(nhoodsID) = rownames(select_nhood)
  #nhoodsInfo = data.frame(cellID = rownames(select_nhood), nhoodsID = hoodsID)
  return(list(da_results = da_results, counts = counts, nhoodsID = nhoodsID))
}
```

```{r}
x = milo
design = ~ age + gender + condition
design.df = designDF
testNhoods <- function(x, design, design.df,
                       fdr.weighting=c("k-distance", "neighbour-distance", "max", "graph-overlap", "none"),
                       min.mean=0, model.contrasts=NULL, robust=TRUE, reduced.dim="PCA",
                       norm.method=c("TMM", "RLE", "logMS")){
    if(is(design, "formula")){
        model <- model.matrix(design, data=design.df)
        rownames(model) <- rownames(design.df)
    } else if(is(design, "matrix")){
        model <- design
        if(nrow(model) != nrow(design.df)){
            stop("Design matrix and model matrix are not the same dimensionality")
        }

        if(any(rownames(model) != rownames(design.df))){
            warning("Design matrix and model matrix dimnames are not the same")
            # check if rownames are a subset of the design.df
            check.names <- any(rownames(model) %in% rownames(design.df))
            if(isTRUE(check.names)){
                rownames(model) <- rownames(design.df)
            } else{
                stop("Design matrix and model matrix rownames are not a subset")
            }
        }
    }

    if(!is(x, "Milo")){
        stop("Unrecognised input type - must be of class Milo")
    } else if(.check_empty(x, "nhoodCounts")){
        stop("Neighbourhood counts missing - please run countCells first")
    }

    if(!any(norm.method %in% c("TMM", "logMS", "RLE"))){
        stop("Normalisation method ", norm.method, " not recognised. Must be either TMM, RLE or logMS")
    }

    if(!reduced.dim %in% reducedDimNames(x)){
        stop(reduced.dim, " is not found in reducedDimNames. Avaiable options are ", paste(reducedDimNames(x), collapse=","))
    }

    subset.counts <- FALSE
    if(ncol(nhoodCounts(x)) != nrow(model)){
        # need to allow for design.df with a subset of samples only
        if(all(rownames(model) %in% colnames(nhoodCounts(x)))){
            message("Design matrix is a strict subset of the nhood counts")
            subset.counts <- TRUE
        } else{
            stop("Design matrix (", nrow(model), ") and nhood counts (",
                 ncol(nhoodCounts(x)), ") are not the same dimension")
        }
    }

    # assume nhoodCounts and model are in the same order
    # cast as DGEList doesn't accept sparse matrices
    # what is the cost of cast a matrix that is already dense vs. testing it's class
    if(min.mean > 0){
        if(isTRUE(subset.counts)){
            keep.nh <- rowMeans(nhoodCounts(x)[, rownames(model)]) >= min.mean
        } else{
            keep.nh <- rowMeans(nhoodCounts(x)) >= min.mean
        }
    } else{
        if(isTRUE(subset.counts)){
            keep.nh <- rep(TRUE, nrow(nhoodCounts(x)[, rownames(model)]))
        }else{
            keep.nh <- rep(TRUE, nrow(nhoodCounts(x)))
        }
    }

    if(isTRUE(subset.counts)){
        keep.samps <- intersect(rownames(model), colnames(nhoodCounts(x)[keep.nh, ]))
    } else{
        keep.samps <- colnames(nhoodCounts(x)[keep.nh, ])
    }

    if(any(colnames(nhoodCounts(x)[keep.nh, keep.samps]) != rownames(model)) & !any(colnames(nhoodCounts(x)[keep.nh, keep.samps]) %in% rownames(model))){
        stop("Sample names in design matrix and nhood counts are not matched.
             Set appropriate rownames in design matrix.")
    } else if(any(colnames(nhoodCounts(x)[keep.nh, keep.samps]) != rownames(model)) & any(colnames(nhoodCounts(x)[keep.nh, keep.samps]) %in% rownames(model))){
        warning("Sample names in design matrix and nhood counts are not matched. Reordering")
        model <- model[colnames(nhoodCounts(x)[keep.nh, keep.samps]), ]
    }

    if(length(norm.method) > 1){
        message("Using TMM normalisation")
        dge <- DGEList(counts=nhoodCounts(x)[keep.nh, keep.samps],
                       lib.size=colSums(nhoodCounts(x)[keep.nh, keep.samps]))
        dge <- calcNormFactors(dge, method="TMM")
    } else if(norm.method %in% c("TMM")){
        message("Using TMM normalisation")
        dge <- DGEList(counts=nhoodCounts(x)[keep.nh, keep.samps],
                       lib.size=colSums(nhoodCounts(x)[keep.nh, keep.samps]))
        dge <- calcNormFactors(dge, method="TMM")
    } else if(norm.method %in% c("RLE")){
        message("Using RLE normalisation")
        dge <- DGEList(counts=nhoodCounts(x)[keep.nh, keep.samps],
                       lib.size=colSums(nhoodCounts(x)[keep.nh, keep.samps]))
        dge <- calcNormFactors(dge, method="RLE")
    }else if(norm.method %in% c("logMS")){
        message("Using logMS normalisation")
        dge <- DGEList(counts=nhoodCounts(x)[keep.nh, keep.samps],
                       lib.size=colSums(nhoodCounts(x)[keep.nh, keep.samps]))
    }

    dge <- estimateDisp(dge, model)
    fit <- glmQLFit(dge, model, robust=robust)
    if(!is.null(model.contrasts)){
        mod.constrast <- makeContrasts(contrasts=model.contrasts, levels=model)
        res <- as.data.frame(topTags(glmQLFTest(fit, contrast=mod.constrast),
                                     sort.by='none', n=Inf))
    } else{
        n.coef <- ncol(model)
        res <- as.data.frame(topTags(glmQLFTest(fit, coef=n.coef), sort.by='none', n=Inf))
    }

    res$Nhood <- as.numeric(rownames(res))
    message("Performing spatial FDR correction with", fdr.weighting[1], " weighting")
    mod.spatialfdr <- graphSpatialFDR(x.nhoods=nhoods(x),
                                      graph=graph(x),
                                      weighting=fdr.weighting,
                                      k=x@.k,
                                      pvalues=res[order(res$Nhood), ]$PValue,
                                      indices=nhoodIndex(x),
                                      distances=nhoodDistances(x),
                                      reduced.dimensions=reducedDim(x, reduced.dim))

    res$SpatialFDR[order(res$Nhood)] <- mod.spatialfdr
    res
}
```


