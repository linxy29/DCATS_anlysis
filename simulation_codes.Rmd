---
title: "Simulation Codes"
output: html_document
---

## Theoretical Simulation

In the following simulation, 1) the cluster numbers(K) is 3; 2) number of replicates is 7 and 6 in condition 1 and 2; 3) sample sizes of each replicates follow a uniform distribution with range from 500 to 2000.

```{r,message=FALSE,warning=FALSE}
library(splatter)
library(Seurat)
library(speckle)
library(DCATS)
library(ggplot2)
library(tidyverse)
library(diffcyt)
library(MCMCpack)
```

```{r}
source("functionsV2.r")
```

```{r}
K = 3  # number of cluster
totals1 = ceiling(runif(7, 500, 2000))  # number of replicates + sample size in each replicate
totals2 = ceiling(runif(6, 500, 2000))
diri_s1 = c(1/3, 1/3, 1/3) * 20  # True proportions + concentration
diri_s2 = c(1/3, 1/2, 1/6) * 20
simil_mat = get_similarity_mat(K, confuse_rate=0.2)  # similarity matrix used in simulator to introduce misclassification
```

```{r}
set.seed(123)
simulationDF = data.frame()
for (i in 1:50){
  sim_dat <- DCATS::simulator_base(totals1, totals2, diri_s1, diri_s2, simil_mat)
  ## introduce more misclassification manually
  rate1 = runif(dim(sim_dat$numb_cond1)[1], -0.2, 0.2)
  change_num = (sim_dat$numb_cond1[,1]*rate1) %>% round()
  sim_dat$numb_cond1[,1] = sim_dat$numb_cond1[,1] - change_num
  sim_dat$numb_cond1[,3] = sim_dat$numb_cond1[,3] + change_num
  
  rate2 = runif(dim(sim_dat$numb_cond2)[1], -0.2, 0.2)
  change_num = (sim_dat$numb_cond2[,1]*rate2) %>% round()
  sim_dat$numb_cond2[,1] = sim_dat$numb_cond2[,1] - change_num
  sim_dat$numb_cond2[,3] = sim_dat$numb_cond2[,3] + change_num
  ## calculate true matrix
  change_rate = (sum(rate1*sim_dat$numb_cond1[,1]) + sum(rate2*sim_dat$numb_cond2[,2]))/(sum(sim_dat$numb_cond1[,1]) + sum(sim_dat$numb_cond2[,1]))
  if (change_rate > 0){
    simil_matT = rbind(c(1-change_rate, 0, change_rate), c(0, 1, 0), c(0, 0, 1))
} else {
  simil_matT = rbind(c(1, 0, 0), c(0, 1, 0), c(-change_rate, 0, 1+change_rate))
}
  ## DCATS---betabinLRT
  betabin_noBC = betabinLRT_rw(as.matrix(sim_dat$numb_cond1), as.matrix(sim_dat$numb_cond2), bias_corr = FALSE)
  ##  DCATS---betabinLRT with Bias correction from similarity matrix
  simil_matI = get_similarity_mat(K, confuse_rate=0)
  simil_matU = get_similarity_mat(K, confuse_rate=0.1)
  betabin_wBC_I = betabinLRT_rw(as.matrix(sim_dat$numb_cond1), as.matrix(sim_dat$numb_cond2), bias_corr = TRUE, similarity_mat = simil_matI)
  betabin_wBC_U = betabinLRT_rw(as.matrix(sim_dat$numb_cond1), as.matrix(sim_dat$numb_cond2), bias_corr = TRUE, similarity_mat = simil_matU)
  betabin_wBC_T = betabinLRT_rw(as.matrix(sim_dat$numb_cond1), as.matrix(sim_dat$numb_cond2), bias_corr = TRUE, similarity_mat = simil_matT)
  ## DCATS---betabin with similarity matrix (backward-forward)
  betabin_wMI = dcats_betabin(as.matrix(sim_dat$numb_cond1), as.matrix(sim_dat$numb_cond2), similarity_mat = simil_matI, n_samples = 100, binom_only = FALSE)
  betabin_wMU = dcats_betabin(as.matrix(sim_dat$numb_cond1), as.matrix(sim_dat$numb_cond2), similarity_mat = simil_matU, n_samples = 100, binom_only = FALSE)
  betabin_wMT = dcats_betabin(as.matrix(sim_dat$numb_cond1), as.matrix(sim_dat$numb_cond2), similarity_mat = simil_matT, n_samples = 100, binom_only = FALSE)
  bin_wMI = dcats_betabin(as.matrix(sim_dat$numb_cond1), as.matrix(sim_dat$numb_cond2), similarity_mat = simil_matI, n_samples = 100)
  bin_wMU = dcats_betabin(as.matrix(sim_dat$numb_cond1), as.matrix(sim_dat$numb_cond2), similarity_mat = simil_matU, n_samples = 100)
  bin_wMT = dcats_betabin(as.matrix(sim_dat$numb_cond1), as.matrix(sim_dat$numb_cond2), similarity_mat = simil_matT, n_samples = 100)
  ## Fisher's exact test
  fisher_pvals = getFisher(as.matrix(sim_dat$numb_cond1), as.matrix(sim_dat$numb_cond2))
  all_res = data.frame(cluster = c("A", "B", "C"), truth = c("N", "P", "P")) %>% 
    mutate(betabin_noBC_pvals = betabin_noBC$pvals,
           betabin_wBCI_pvals = betabin_wBC_I$pvals,
           betabin_wBCU_pvals = betabin_wBC_U$pvals,
           betabin_wBCT_pvals = betabin_wBC_T$pvals,
           betabin_wMI_pvals = betabin_wMI$pvals,
           betabin_wMU_pvals = betabin_wMU$pvals,
           betabin_wMT_pvals = betabin_wMT$pvals,
           bin_wMI_pvals = bin_wMI$pvals,
           bin_wMU_pvals = bin_wMU$pvals,
           bin_wMT_pvals = bin_wMT$pvals,
           fisher_pvals = fisher_pvals)
  simulationDF = rbind(simulationDF, all_res)
}
head(simulationDF)
```

```{r}
library(pROC)
methods = colnames(simulationDF)[3:13]
roc_rose <- plot(roc(simulationDF$truth, simulationDF[,3]), legacy.axes = TRUE, print.auc = TRUE, print.auc.y = .73, print.auc.x = .7, col = 1)
graphics::text(0.1, 0.7, paste(methods[1]), col=1)
for (i in 2:11){
  roc_rose <- plot(roc(simulationDF$truth, simulationDF[,i+2]), legacy.axes = TRUE, print.auc = TRUE, print.auc.y = .73-(i-1)*0.07, print.auc.x = .7, col = i, add = TRUE)
  graphics::text(0.1, 0.7-(i-1)*0.07, paste(methods[i]), col=i)
}
```

## Theoretical Simulation with boxplots output

Fig 1 (theoretical simulation might be enough): the usefulness of using similarity matrix to correct the bias;

Draw a boxplot to show AUC results of DCATS, chi-square, scDC(, fisher) without BC, with BC and with BC using resampling.

```{r,message=FALSE,warning=FALSE}
library(splatter)
library(Seurat)
library(speckle)
library(DCATS)
library(ggplot2)
library(tidyverse)
library(diffcyt)
library(MCMCpack)
```

```{r}
source("functionsV2.r")
```

```{r}
cluster_num = 7  # numbers of clusters
concentration = 50 # indicate how simulated proportion far away from true, the larger the closer
rep1 = 6
rep2 = 4
simulation_times = 50
simulation_size = 50
sample_size1 = 1000
sample_size2 = 2000
```

```{r}
## more negative
if (cluster_num == 3){
  probC1 = c(1/3, 1/3, 1/3)  # True proportions
  probC2 = c(1/3, 1/2, 1/6)
  truthRes = c("N", "P", "P")
} else if (cluster_num == 7){
  probC1 = c(rep(0.1, 4), rep(0.2, 3))
  probC2 = c(0.1, 0.1, 0.1, 0.15, 0.2, 0.3, 0.05)
  truthRes = c("N", "N", "N", "P", "N", "P", "P")
} else if (cluster_num == 12) {
  probC1 = c(rep(0.1, 4), rep(0.2, 2), rep(0.05, 2), rep(0.025, 4))
  probC2 = c(0.1, 0.1, 0.1, 0.1, 0.2, 0.15, 0.05, 0.075, 0.05, 0.025, 0.025, 0.025)
  truthRes = c("N", "N", "N", "N", "N", "P", "N", "P", "P", "N", "N", "N")
}
```

```{r}
## the result of this chunk is saved
set.seed(123)
simulationDF_list = vector(mode = "list", length = simulation_times)
for (j in 1:simulation_times) {
  simulationDF = data.frame()
  for (i in 1:simulation_size){
    ## create confusion matrix that is not uniformly distributed
    simil_mat = get_similarity_mat(cluster_num, confuse_rate=0.2)
    if (FALSE){
      mis_idx = runif(1, -0.2, 0.2)
      change_rate = simil_mat[1,1]*abs(mis_idx)
      if (mis_idx < 0){
        simil_mat[1,1] = simil_mat[1,1] - change_rate
        simil_mat[1,3] = simil_mat[1,3] + change_rate
        } else {
          simil_mat[3,1] = simil_mat[1,1] - change_rate
          simil_mat[3,3] = simil_mat[1,3] + change_rate
        }
      }
    
    
    ## Data generation part
    totals1 = ceiling(runif(rep1, sample_size1, sample_size2))
    totals2 = ceiling(runif(rep2, sample_size1, sample_size2))
    diri_s1 = probC1 * concentration
    diri_s2 = probC2 * concentration
    sim_dat <- DCATS::simulator_base(totals1, totals2, diri_s1, diri_s2, simil_mat)
    numb_cond1 = as.matrix(sim_dat$numb_cond1)
    numb_cond2 = as.matrix(sim_dat$numb_cond2)
    
    ## Test part 1
    ### DCATS
    dcats_res1 = betabinLRT_rw(numb_cond1, numb_cond2, bias_corr = FALSE)
    ### fisher
    fisher_pvals1 = getFisher(numb_cond1, numb_cond2)
    
    ## Bias Correction
    numb_cond1BC = numb_cond1
    numb_cond2BC = numb_cond2
    for (i in seq_len(nrow(numb_cond1))) {
      numb_cond1BC[i, ] <- sum(numb_cond1[i, ]) *
        multinom_EM(numb_cond1[i, ], simil_mat, verbose = FALSE)$mu
      numb_cond1BC[i, ] = ceiling(numb_cond1BC[i, ])
      }
    for (i in seq_len(nrow(numb_cond2))) {
      numb_cond1BC[i, ] <- sum(numb_cond2[i, ]) *
        multinom_EM(numb_cond2[i, ], simil_mat, verbose = FALSE)$mu
      numb_cond1BC[i, ] = ceiling(numb_cond1BC[i, ])
      }
  
    ## Test part 2
    ### DCATS
    dcats_res2 = betabinLRT_rw(numb_cond1BC, numb_cond2BC, bias_corr = FALSE)
    ### fisher
    fisher_pvals2 = getFisher(numb_cond1BC, numb_cond2BC)
  
    all_res = data.frame(cluster = c("A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L")[1:cluster_num], truth = truthRes) %>% 
      mutate(dcats_noBC = dcats_res1$pvals,
            fisher_noBC = fisher_pvals1,
            dcats_withBC = dcats_res2$pvals,
            fisher_withBC = fisher_pvals2)

    simulationDF = rbind(simulationDF, all_res)
    }
  simulationDF_list[[j]] = simulationDF
}

file_name = str_c("./data/simulationRES/replicates", as.character(rep1), "&", as.character(rep2), "_K", as.character(cluster_num), "_con", as.character(concentration), "_countSim.RData")
save(simulationDF_list, file = file_name)

## send email after finishing
sendEmail("Simulation is done!!")
```

```{r}
file_name = str_c("./data/simulationRES/replicates", as.character(rep1), "&", as.character(rep2), "_K", as.character(cluster_num), "_con", as.character(concentration), "_countSim.RData")
load(file_name)

evaluationDF = data.frame()
len = length(simulationDF_list)
for (j in 1:len){
  simulationDF = simulationDF_list[[j]] %>% 
  mutate(dcats_tf1 = ifelse(dcats_noBC < 0.05, "P", "N"),
         fisher_tf1 = ifelse(fisher_noBC < 0.05, "P", "N"),
         dcats_tf2 = ifelse(dcats_withBC < 0.05, "P", "N"),
         fisher_tf2 = ifelse(fisher_withBC < 0.05, "P", "N"))
  methods = colnames(simulationDF)[3:6]
  numb_mthd = length(methods)
  auc = rep(NA, numb_mthd)
  recall = rep(NA, numb_mthd)
  FNR = rep(NA, numb_mthd)
  FPR = rep(NA, numb_mthd)
  specificity = rep(NA, numb_mthd)
  precision = rep(NA, numb_mthd)
  FDR = rep(NA, numb_mthd)
  FOR = rep(NA, numb_mthd)
  NPV = rep(NA, numb_mthd)
  accuracy = rep(NA, numb_mthd)
  F1 = rep(NA, numb_mthd)
  for (i in 3:6){
    auc[i-2] = roc(simulationDF$truth, simulationDF[,i])$auc
    truth = simulationDF$truth
    pred = simulationDF[, i+4]
    confu_mtr = table(pred, truth)
    TN = 0
    FN = 0
    FP = 0
    TP = 0
    if(dim(confu_mtr)[1] == 2){
      TN = confu_mtr[1,1] 
      FN = confu_mtr[1,2]
      FP = confu_mtr[2,1]
      TP = confu_mtr[2,2]
    } else {
      if (unique(pred) == "N"){
        TN = confu_mtr[1,1] 
        FN = confu_mtr[1,2]
      } else {
          FP = confu_mtr[1,1]
          TP = confu_mtr[1,2]
        }
    }
    truthN = TN + FP
    truthP = FN + TP
    predP = TP + FP
    predN = FN + TN
    recall[i-2] = TP/truthP
    FNR[i-2] = FN/truthP
    FPR[i-2] = FP/truthN
    specificity[i-2] = TN/truthN
    precision[i-2] = TP/predP
    FDR[i-2] = FP/predP
    FOR[i-2] = FN/predN
    NPV[i-2] = TN/predN
    accuracy[i-2] = (TP+TN)/(truthP+truthN)
    F1[i-2] = 2*TP/(2*TP+FP+FN)
      
  res = data.frame(trial = as.character(j), methods = methods, auc = auc, recall = recall, FNR = FNR, FPR = FPR, specificity = specificity, precision = precision, FDR = FDR, FOR = FOR, NPV = NPV, accuracy = accuracy, F1 = F1)
    }
    evaluationDF = rbind(evaluationDF, res)
}

evaluationDF %>% 
  tidyr::separate(methods, c("method", "condition"), sep = "_") %>% 
  pivot_longer(
    auc:F1,
    names_to = "statistics", 
    values_to = "value") %>% 
  mutate(statistics = as.factor(statistics),
         statistics = fct_relevel(statistics, "auc", "recall", "specificity", "precision", "NPV", "accuracy", "F1")) %>% 
  ggplot(aes(x = statistics, y = value, color = method)) + geom_boxplot() + facet_grid(.~condition) +
  theme(axis.text.x = element_text(angle = 45))
```

## Simulation with transcriptome information

```{r, message=FALSE, warning=FALSE}
library(splatter)
library(Seurat)
library(SeuratWrappers)
library(speckle)
library(DCATS)
library(ggplot2)
library(tidyverse)
library(diffcyt)
library(MCMCpack)
library(scdney)
```

```{r, message=FALSE, warning=FALSE}
source("functionsV2.r")
source("glm.R")     # for scDC
```

```{r}
cell_pool = "mis1"  # cell pool used
cluster_num = 3  # numbers of clusters
probC1 = c(1/3, 1/3, 1/3)  # True proportions
probC2 = c(1/3, 1/2, 1/6)
concentration = 50 # indicate how simulated proportion far away from true, the larger the closer
setresolu = 0.2
rep1 = 3
rep2 = 2
simulation_times = 50
sample_size1 = 800
sample_size2 = 1500
```

```{r}
if (cell_pool == "discrete"){
  load("./data/cells_pool3.RData")
} else if (cell_pool == "mis1") {
    load("./data/cells_pool3_close.RData")
}
```

```{r, message=FALSE, warning=FALSE}
## output data
simulationDF = data.frame()  # data frame to store test result
time = matrix(NA, nrow = simulation_times, ncol = 6) # matrix contains time for each test need in each simulation
true_countL = vector(mode = "list", length = simulation_times) # list contains the count table of each true cluster
seurat_countL = vector(mode = "list", length = simulation_times) # list contains the count table of each cluster defined by seurat
knn_matrixL = vector(mode = "list", length = simulation_times) # list contains the knn matrix getting from each simulation
true_matrixL = vector(mode = "list", length = simulation_times) # list contains the true similarity matrix getting from each simulation

set.seed(123)
for (i in 1:simulation_times){
  timeL = rep(NA, 6) # DCATS w/wto simularity matrix, fisher, speckle, diffcyt, scDC
  ## simulation
  simulation = simulator_fastMNN(totals1 = runif(rep1, sample_size1, sample_size2), totals2 = runif(rep2, sample_size1, sample_size2), probC1, probC2, setresolu, sim_mat)
  if (is.na(simulation)[1] == FALSE){
    true_countL[[i]] = list(cond1 = simulation$numb_cond1, cond2 = simulation$numb_cond2)
    ## data convert
    numb_cond1 = simulation$dfRes %>% 
      filter(condition == "Cond1") %>%
      group_by(clusterRes, batch) %>% 
      summarise(n = n()) %>% 
      pivot_wider(names_from = "clusterRes", values_from = "n") %>% 
      column_to_rownames(var = "batch")
    numb_cond2 = simulation$dfRes %>% 
      filter(condition == "Cond2") %>%
      group_by(clusterRes, batch) %>% 
      summarise(n = n()) %>% 
      pivot_wider(names_from = "clusterRes", values_from = "n") %>% 
      column_to_rownames(var = "batch")
    numb_cond1[is.na(numb_cond1)] <- 0
    numb_cond2[is.na(numb_cond2)] <- 0
    conf.mat<-table(Idents(simulation$integratedSamples), simulation$trueLabels)
    true.conf<-t(t(conf.mat)/apply(conf.mat,2,sum))
    library(clue)
    order2 = as.vector(solve_LSAP(true.conf, maximum = TRUE))
    seurat_countL[[i]] = list(cond1 = numb_cond1[,order2], cond2 = numb_cond2[,order2])
    L_sum1 = colSums(numb_cond1)
    L_sum2 = colSums(numb_cond2)
    decider = sum(L_sum1 > 10)+sum(L_sum2 > 10)
    if (decider == cluster_num*2) {   # if one cluster has least than 10 cells in one condition, then won't continue
      ## test
      ## DCATS---betabinLRT
      t1start = Sys.time()
      betabin_noBC = betabinLRT_rw(as.matrix(numb_cond1), as.matrix(numb_cond2), bias_corr = FALSE)
      timeL[1] = Sys.time() - t1start
      ##  DCATS---betabinLRT with Bias correction from similarity matrix
      ## KNN matrix
      graphs = simulation$integratedSamples@graphs$RNA_snn
      labels = Idents(simulation$integratedSamples)
      knn_mat = KNN_transition(graphs, labels)
      order1 = colnames(numb_cond1)
      simil_matK = knn_mat[order1, order1]
      knn_matrixL[[i]] = simil_matK
      simil_matU = get_similarity_mat(cluster_num, confuse_rate=0.1)
      simil_matT = t(true.conf[order2,])
      true_matrixL[[i]] = simil_matT
      betabin_wBC_K = betabinLRT_rw(as.matrix(numb_cond1), as.matrix(numb_cond2), bias_corr = TRUE, similarity_mat = simil_matK)
      betabin_wBC_U = betabinLRT_rw(as.matrix(numb_cond1), as.matrix(numb_cond2), bias_corr = TRUE, similarity_mat = simil_matU)
      betabin_wBC_T = betabinLRT_rw(as.matrix(numb_cond1), as.matrix(numb_cond2), bias_corr = TRUE, similarity_mat = simil_matT)
      ## DCATS---betabin with similarity matrix (backward-forward)
      t2start = Sys.time()
      betabin_wMK = dcats_betabin(as.matrix(numb_cond1), as.matrix(numb_cond2), similarity_mat = simil_matK, n_samples = 100, binom_only = FALSE)
      timeL[2] = Sys.time() - t2start
      betabin_wMU = dcats_betabin(as.matrix(numb_cond1), as.matrix(numb_cond2), similarity_mat = simil_matU, n_samples = 100, binom_only = FALSE)
      betabin_wMT = dcats_betabin(as.matrix(numb_cond1), as.matrix(numb_cond2), similarity_mat = simil_matT, n_samples = 100, binom_only = FALSE)
      bin_wMK = dcats_betabin(as.matrix(numb_cond1), as.matrix(numb_cond2), similarity_mat = simil_matK, n_samples = 100)
      bin_wMU = dcats_betabin(as.matrix(numb_cond1), as.matrix(numb_cond2), similarity_mat = simil_matU, n_samples = 100)
      bin_wMT = dcats_betabin(as.matrix(numb_cond1), as.matrix(numb_cond2), similarity_mat = simil_matT, n_samples = 100)
      ## Fisher's exact test
      t3start = Sys.time()
      fisher_pvals = getFisher(as.matrix(numb_cond1), as.matrix(numb_cond2))
      timeL[3] = Sys.time() - t3start
      ## speckle
      t4start = Sys.time()
      speckleRes = propeller(clusters = simulation$dfRes$clusterRes, sample = simulation$dfRes$batch, group = simulation$dfRes$condition) %>% 
        dplyr::rename(cluster = BaselineProp.clusters,
                      speckle_pvals = FDR) %>%
        dplyr::select(cluster, speckle_pvals)
      timeL[4] = Sys.time() - t4start
      ## diffcyt
      t5start = Sys.time()
      diffcytP = getDiffcyt(numb_cond1, numb_cond2, simulation$integratedSamples)
      timeL[5] = Sys.time() - t5start
      ## scDC
      t6start = Sys.time()
      res_scDC <- scDC_noClustering(cellTypes = simulation$dfRes$clusterRes, simulation$dfRes$batch, calCI = TRUE, calCI_method = c("percentile", "BCa", "multinom"),nboot = 1000, verbose = FALSE)
      res_GLM <- fitGLM(res_scDC, c(rep("cond1",rep1*cluster_num),rep("cond2",rep2*cluster_num)), pairwise = FALSE, fixed_only = TRUE, verbose = FALSE)
      timeL[6] = Sys.time() - t6start
      scDCRes_temp = summary(res_GLM$pool_res_fixed)
      scDCRes = scDCRes_temp[c(cluster_num+1,(dim(scDCRes_temp)[1]-cluster_num+2):dim(scDCRes_temp)[1]),]
      ## results
      cluster_map = data.frame(originLab = order2, cluster = c("A", "B", "C")) %>% 
        arrange(originLab) %>% 
        mutate(truth = c("N", "P", "P")) %>% 
        arrange(cluster) %>% 
        dplyr::select(-originLab)
      all_res = cluster_map %>% 
        mutate(betabin_noBC_pvals = betabin_noBC$pvals,
               betabin_wBCK_pvals = betabin_wBC_K$pvals,
               betabin_wBCU_pvals = betabin_wBC_U$pvals,
               betabin_wBCT_pvals = betabin_wBC_T$pvals,
               betabin_wMK_pvals = betabin_wMK$pvals,
               betabin_wMU_pvals = betabin_wMU$pvals,
               betabin_wMT_pvals = betabin_wMT$pvals,
               bin_wMK_pvals = bin_wMK$pvals,
               bin_wMU_pvals = bin_wMU$pvals,
               bin_wMT_pvals = bin_wMT$pvals,
               fisher_pvals = fisher_pvals,
               scDC_pvals = scDCRes$p.value) %>%
        merge(speckleRes, by = "cluster") %>% 
        merge(diffcytP, by = "cluster")
      simulationDF = rbind(simulationDF, all_res)
      time[i,] = timeL
    }
  }
}

## send email after finishing
sendEmail("Simulation is done!!")

file_name = str_c("./data/simulationDF/replicates", as.character(rep1), "&", as.character(rep2), "_K", as.character(cluster_num), "_con", as.character(concentration), "_", cell_pool, ".RData")
colnames(time) = c("DCATS_wtoM", "DCATS_wM", "fisher", "speckle", "diffcyt", "scDC")
save(simulationDF, time, file = file_name)
load(file_name)
head(simulationDF)
```

```{r}
save(simulationDF, true_countL, seurat_countL, knn_matrixL, true_matrixL, file = "./data/simulation_codes.RData")
```

```{r, message=FALSE}
library(pROC)
methods = colnames(simulationDF)[3:16]
roc_rose <- plot(roc(simulationDF$truth, simulationDF[,3]), legacy.axes = TRUE, print.auc = TRUE, print.auc.y = .7, print.auc.x = .6, col = 1)
graphics::text(0.1, 0.69, paste(methods[1]), col=1)
for (i in 2:14){
  roc_rose <- plot(roc(simulationDF$truth, simulationDF[,i+2]), legacy.axes = TRUE, print.auc = TRUE, print.auc.y = .7-(i-1)*0.05, print.auc.x = .6, col = i, add = TRUE)
  graphics::text(0.1, 0.69-(i-1)*0.05, paste(methods[i]), col=i)
}

print("Time")
apply(na.omit(time), 2, mean)
```

```{r}
simulationRes = simulationDF %>% 
  mutate(truth = ifelse(truth == "P", 1, 0),
         betabin_noBC_Res = ifelse(betabin_noBC_pvals < 0.05, 1, 0),
         betabin_wBCK_Res = ifelse(betabin_wBCK_pvals < 0.05, 1, 0),
         betabin_wBCU_Res = ifelse(betabin_wBCU_pvals < 0.05, 1, 0),
         betabin_wBCT_Res = ifelse(betabin_wBCT_pvals < 0.05, 1, 0),
         betabin_wMK_Res = ifelse(betabin_wMK_pvals < 0.05, 1, 0),
         betabin_wMU_Res = ifelse(betabin_wMU_pvals < 0.05, 1, 0),
         betabin_wMT_Res = ifelse(betabin_wMU_pvals < 0.05, 1, 0),
         bin_wMK_Res = ifelse(bin_wMK_pvals < 0.05, 1, 0),
         bin_wMU_Res = ifelse(bin_wMU_pvals < 0.05, 1, 0),
         bin_wMT_Res = ifelse(bin_wMU_pvals < 0.05, 1, 0),
         fisher_Res = ifelse(fisher_pvals < 0.05, 1, 0),
         scDC_Res = ifelse(scDC_pvals < 0.05, 1, 0),
         speckle_Res = ifelse(speckle_pvals < 0.05, 1, 0),
         diffcyt_Res = ifelse(diffcyt_pvals < 0.05, 1, 0))

for (i in 17:30){
  simulationRes[,i] = (simulationRes[,i] - simulationRes$truth) %>% 
    abs()
}

print("errorRate0.05")
errorRate = colSums(simulationRes[,17:30])/dim(simulationRes[,17:30])[1]
errorRate[order(errorRate)]
```

