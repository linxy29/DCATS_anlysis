---
title: "Figure1 Draft"
output: html_document
---

```{r,message=FALSE,warning=FALSE}
library(splatter)
library(Seurat)
library(speckle)
library(DCATS)
library(ggplot2)
library(tidyverse)
library(MCMCpack)
library(pROC)
```

```{r}
source("functionsV2.r")
options(future.globals.maxSize = 20000 * 1024^2) # 20G memory
```

```{r}
theme_set(theme_classic()+
    theme(panel.border = element_blank(),
          legend.key = element_blank(),
          axis.ticks = element_blank(),
          panel.grid = element_blank(),
          panel.grid.minor = element_blank(), 
          panel.grid.major = element_blank(),
          panel.background = element_blank(),
          legend.background = element_blank(),
          plot.background = element_rect(fill = "transparent",colour = NA))+
      theme(axis.text=element_text(size=12),
        axis.title=element_text(size=14)))
```

```{r}
cluster_num = 3  # numbers of clusters
concentration = 70 # indicate how simulated proportion far away from true, the larger the closer
#rep1 = 3
rep1 = 2
rep2 = 3
#rep2 = 4
simulation_times = 20
simulation_size = 50
sample_size1 = 1000
sample_size2 = 2000

probC1 = c(1/3, 1/3, 1/3)  # True proportions
probC2 = c(1/3, 1/2, 1/6)
truthRes = c("N", "P", "P")
```

Function use to calculate fisher with boostrap

```{r}
getFisher_bs = function(counts1, counts2, similarity_mat=NULL, n_samples=50, pseudo_count=NULL) {
  ## bootstrap
  prop1 <- counts1 / rowSums(counts1)
  prop2 <- counts2 / rowSums(counts2)
  
  ## using estimated the latent cell counts
  counts1_latent = counts1
  counts2_latent = counts2
  if(!is.null(similarity_mat)) {
    for (i in seq_len(nrow(counts1))) {
      counts1_latent[i, ] <- sum(counts1[i, ]) * multinom_EM(counts1[i, ], similarity_mat, verbose = FALSE)$mu
      }
    for (i in seq_len(nrow(counts2))) {
      counts2_latent[i, ] <- sum(counts2[i, ]) * multinom_EM(counts2[i, ], similarity_mat, verbose = FALSE)$mu
    }
    }
  
  ## number of cell types
  K <- ncol(counts1)
  if (is.null(similarity_mat)) {
    n_samples <- 1
    }
  
  if (!is.null(n_samples) && !is.null(similarity_mat)) {
    counts1_use <- matrix(0, nrow(counts1) * n_samples, K)
    counts2_use <- matrix(0, nrow(counts2) * n_samples, K)
    for (i in seq_len(nrow(counts1))) {
      idx <- seq((i - 1) * n_samples + 1, i * n_samples)
      for (j in seq_len(K)) {
        counts1_use[idx, ] <- (
          counts1_use[idx, ] + t(rmultinom(n_samples,counts1_latent[i, j], similarity_mat[j, ])))
      }
      }
    for (i in seq_len(nrow(counts2))) {
      idx <- seq((i - 1) * n_samples + 1, i * n_samples)
      for (j in seq_len(K)) {
        counts2_use[idx, ] <- (
          counts2_use[idx, ] + t(rmultinom(n_samples,counts2_latent[i, j], similarity_mat[j, ])))
      }
      }
    } else{
      counts1_use <- counts1
      counts2_use <- counts2
      }

    # adding pseudo counts
    if (is.null(pseudo_count)) {
        if (any(colMeans(counts1) == 0) || any(colMeans(counts2) == 0) ) {
            print(paste("Empty cell type exists in at least one conidtion;", "adding replicate & condition specific pseudo count:"))
          counts1_use <- counts1_use + 1
          counts2_use <- counts2_use + 1
          }
      } else {
        counts1_use = counts1_use + pseudo_count
        counts2_use = counts2_use + pseudo_count
    }
    
  ## fisher test
  fisher_pval <- matrix(NA, n_samples, K)
  for (ir in seq_len(n_samples)) {           ## for each sampling
    idx1 <- seq(1, nrow(counts1_use), n_samples) + ir - 1
    idx2 <- seq(1, nrow(counts2_use), n_samples) + ir - 1
    fisher_pval[ir,] = getFisher(counts1_use[idx1,], counts2_use[idx2,])
  }
  
  return(fisher_pval)
}
```


Try used the complete version of dcats without fixed phi

```{r}
set.seed(123)

simulationDF_list = vector(mode = "list", length = simulation_times)
for (sim in 1:simulation_times) {
  simulationDF = data.frame()
  for (simsim in 1:simulation_size){
    ## create confusion matrix that is not uniformly distributed
    simil_mat = matrix(c(1, 0, 0, 0, 0.7, 0.3, 0, 0.3, 0.7), ncol = 3)
    
    ## Data generation part
    totals1 = ceiling(runif(rep1, sample_size1, sample_size2))
    totals2 = ceiling(runif(rep2, sample_size1, sample_size2))
    diri_s1 = probC1 * concentration
    diri_s2 = probC2 * concentration
    sim_dat <- DCATS::simulator_base(totals1, totals2, diri_s1, diri_s2, simil_mat)
    numb_cond1 = as.matrix(sim_dat$numb_cond1)
    numb_cond2 = as.matrix(sim_dat$numb_cond2)
    
    ## Test part 1
    ### DCATS
    count_mat = rbind(numb_cond1, numb_cond2)
    design_df = data.frame(condition = c(rep("c1", dim(numb_cond1)[1]), rep("c2", dim(numb_cond2)[1])))
    dcats_res1 = dcats_GLM(count_mat, design_df)
    ### fisher
    fisher_pvals1 = getFisher(numb_cond1, numb_cond2)
    
    ## Test part 2 - only use EM
    ## Bias Correction
    numb_cond1BC = numb_cond1
    numb_cond2BC = numb_cond2
    for (i in seq_len(nrow(numb_cond1))) {
      numb_cond1BC[i, ] <- sum(numb_cond1[i, ]) * multinom_EM(numb_cond1[i, ], simil_mat, verbose = FALSE)$mu
      numb_cond1BC[i, ] = ceiling(numb_cond1BC[i, ])}
    for (i in seq_len(nrow(numb_cond2))) {
      numb_cond2BC[i, ] <- sum(numb_cond2[i, ]) * multinom_EM(numb_cond2[i, ], simil_mat, verbose = FALSE)$mu
      numb_cond2BC[i, ] = ceiling(numb_cond2BC[i, ])}
    
    ### DCATS
    count_mat = rbind(numb_cond1BC, numb_cond2BC)
    dcats_res2 = dcats_GLM(count_mat, design_df)
    ### fisher
    fisher_pvals2 = getFisher(numb_cond1BC, numb_cond2BC)
    
    ## Test part 3
    ### DCATS
    dcats_res3 = dcats_GLM(count_mat, design_df, similarity_mat = simil_mat, fix_phi = 1/sum(concentration+1))
    ### fisher
    fisherM = getFisher_bs(numb_cond1, numb_cond2, similarity_mat = simil_mat)
    fisher_pvals3 = apply(fisherM, 2, median)
    
    all_res = data.frame(cluster = c("A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L")[1:cluster_num], truth = truthRes) %>%
      mutate(dcats_null = dcats_res1$LRT_pvals,
             fisher_null = fisher_pvals1,
             dcats_withBC = dcats_res2$LRT_pvals,
             fisher_withBC = fisher_pvals2,
             dcats_full = dcats_res3$LRT_pvals,
             fisher_full = fisher_pvals3)
    
    simulationDF = rbind(simulationDF, all_res)}
  simulationDF_list[[sim]] = simulationDF
}
save(simulationDF_list, file = "D:/Data/DCATS/simulation/simulationDF_list0803.RData")
```

```{r}
evaluationDF = data.frame()
len = length(simulationDF_list)
#for (j in 1:3){
for (j in 1:len){
  simulationDF = simulationDF_list[[j]] %>% na.omit()
  method = colnames(simulationDF)[3:dim(simulationDF)[2]]
  numb_mthd = length(method)
  sensitivity = rep(NA, numb_mthd)
  specificity = rep(NA, numb_mthd)
  mcc = rep(NA, numb_mthd)
  auc = rep(NA, numb_mthd)
  prauc = rep(NA, numb_mthd)
  F1 = rep(NA, numb_mthd)
  
  truth = simulationDF$truth
  for (i in 3:dim(simulationDF)[2]){
    pred = simulationDF[, i]
    pred_res = ifelse(pred < 0.05, "P", "N")
    TP <- sum(pred_res=="P"&truth=="P")
    TN <- sum(pred_res=="N"&truth=="N")
    FP <- sum(pred_res=="P"&truth=="N")
    FN <- sum(pred_res=="N"&truth=="P")
    truthN = TN + FP
    truthP = FN + TP
    predP = TP + FP
    predN = FN + TN
    sensitivity[i-2] = TP/truthP
    specificity[i-2] = TN/truthN
    mcc[i-2] = (TP*TN-FP*FN)/sqrt(predP*truthP*truthN*predN)
    auc[i-2] = getROC(truth, pred)$auc
    prauc[i-2] = getPRC(truth, pred)$prauc
    F1 = 2*TP/(2*TP+FP+FN)
    
    res = data.frame(trial = as.character(j), method = method, sensitivity = sensitivity, specificity = specificity, mcc = mcc, auc = auc, prauc = prauc, F1 = F1)
    }
    evaluationDF = rbind(evaluationDF, res)
}
```

Plots

```{r}
evaluationDF %>% 
  tidyr::separate(method, c("method", "condition"), sep = "_") %>% 
  pivot_longer(
    sensitivity:specificity,
    names_to = "statistics", 
    values_to = "value") %>% 
  #mutate(condition = ifelse(condition == "withBC", "with Bias Correction", "without Bias Correction"),
         #condition = factor(condition, levels = c("without Bias Correction", "with Bias Correction"))) %>%
  mutate(method = ifelse(method == "dcats", "DCATS", "Fisher")) %>% 
  ggplot(aes(x = statistics, y = value, color = method)) + geom_boxplot() + facet_grid(.~condition) +
    theme(axis.title.x = element_blank()) + 
  scale_color_manual(values=c("#F8766D", "#00BF7D"))
  #ggplot(aes(x = statistics, y = value, color = method)) + geom_boxplot()
#ggsave("./plot/figureA2.png", bg = "transparent")
```

```{r}
evaluationDF %>% 
  tidyr::separate(method, c("method", "condition"), sep = "_") %>% 
  dplyr::select(-sensitivity, -specificity) %>% 
  mutate(method = ifelse(method == "dcats", "DCATS", "Fisher")) %>% 
  #mutate(condition = factor(condition, levels = c("wtoBC", "withBC"))) %>% 
  ggplot(aes(x = condition, y = mcc, color = method)) + geom_boxplot() +
  theme(axis.title.x = element_blank(),
        legend.position = "top") + 
  scale_color_manual(values=c("#F8766D", "#00BF7D"))
#ggsave("C:/#Code/R/slides/image/RPG_discussion/dcats_result1.png", bg = "transparent")
```

```{r}
evaluationDF %>% 
  tidyr::separate(method, c("method", "condition"), sep = "_") %>% 
  mutate(method = ifelse(method == "dcats", "DCATS", "Fisher")) %>% 
  #mutate(condition = factor(condition, levels = c("wtoBC", "withBC"))) %>% 
  ggplot(aes(x = condition, y = prauc, color = method)) + geom_boxplot() +
  theme(axis.title.x = element_blank(),
        legend.position = "top") + 
  scale_color_manual(values=c("#F8766D", "#00BF7D"))
#ggsave("C:/#Code/R/slides/image/RPG_discussion/dcats_result1.png", bg = "transparent")
```

## Add simple gene expression information

```{r, message=FALSE, warning=FALSE}
library(Seurat)
library(SeuratWrappers)
library(speckle)
library(DCATS)
library(ggplot2)
library(tidyverse)
library(diffcyt)
library(MCMCpack)
library(scdney)
library(tidymodels)  ## for DCATS
```

```{r}
cluster_num = 8  # numbers of clusters
concentration = 100 # indicate how simulated proportion far away from true, the larger the closer
setresolu = 0.8
rep1 = 4
rep2 = 4
simulation_times = 30
sample_size1 = 1500
sample_size2 = 2500
cell_pool = "splatter"  # cell pool used, can be selected from ("SPAR", "splatter", "realWorld")
more_negative = ""
```

```{r}
if(cluster_num == 8){
  probC1 = c(rep(0.1, 6), 0.2, 0.2)  # True proportions
  probC2 = c(rep(0.1, 3), 0.05, 0.15, 0.2, 0.2, 0.1)
  truthRes = c(rep("N", 3), rep("P", 3), "N", "P")
} else if (cluster_num == 10){
  probC1 = c(rep(0.1, 5), 0.05, 0.05, 0.05, 0.1, 0.15)  # True proportions
  probC2 = c(rep(0.1, 10))
  truthRes = c(rep("N", 5), rep("P", 5))
} else if (cluster_num == 12){
  probC1 = c(rep(0.1, 4), 0.05, 0.05, 0.05, 0.15, 0.05, 0.05, 0.1, 0.1)  # True proportions
  probC2 = c(rep(0.1, 8), rep(0.05, 4))
  truthRes = c(rep("N", 4), rep("P", 4), "N", "N", "P", "P")
} else {
  print("Not pre-set clutser number")
}
```

```{r, message=FALSE, warning=FALSE}
source("functionsV2.r")
source("glm.R")     # for scDC
options(future.globals.maxSize = 15000 * 1024^2)
```

```{r}
if (cell_pool == "splatter"){
  load(str_c("./data/cells_pool", as.character(cluster_num), "_splatter.RData"))
} else if (cell_pool == "SPAR") {
    load(str_c("./data/cells_pool", as.character(cluster_num), "_SPARSim.RData"))
  
} else if (cell_pool == "realWorld") {
    load(str_c("./data/cells_pool", as.character(cluster_num), "_realWorld.RData"))
}
```

```{r, message=FALSE, warning=FALSE, echo=FALSE}
## output data
simulationDF = data.frame()  # data frame to store test result
time = matrix(NA, nrow = simulation_times, ncol = 8) # matrix contains time for each test need in each simulation and time need to calculate svm/rf matrix
true_countL = vector(mode = "list", length = simulation_times) # list contains the count table of each true cluster
seurat_countL = vector(mode = "list", length = simulation_times) # list contains the count table of each cluster defined by seurat
knn_matrixL = vector(mode = "list", length = simulation_times) # list contains the knn matrix getting from each simulation
true_matrixL = vector(mode = "list", length = simulation_times) # list contains the true similarity matrix getting from each simulation
rf_matrixL = vector(mode = "list", length = simulation_times) # list contains the knn matrix getting from each simulation
svm_matrixL = vector(mode = "list", length = simulation_times) # list contains the true similarity matrix getting from each simulation

set.seed(123)
for (sim in 1:simulation_times){
  print(sim)
  timeL = rep(NA, 8) # DCATS w/wto similarity matrix, fisher, speckle, diffcyt, scDC
  ## simulation
  simulation = simulator_fastMNN(totals1 = runif(rep1, sample_size1, sample_size2), totals2 = runif(rep2, sample_size1, sample_size2), probC1, probC2, setresolu, sim_mat)
  if (is.na(simulation)[1] == FALSE){
    true_countL[[sim]] = c(cond1 = simulation$numb_cond1, cond2 = simulation$numb_cond2)
    
    ## data convert
    numb_cond1 = simulation$dfRes %>% 
      filter(condition == "Cond1") %>%
      group_by(clusterRes, batch) %>% 
      summarise(n = n()) %>% 
      pivot_wider(names_from = "clusterRes", values_from = "n") %>% 
      column_to_rownames(var = "batch")
    numb_cond2 = simulation$dfRes %>% 
      filter(condition == "Cond2") %>%
      group_by(clusterRes, batch) %>% 
      summarise(n = n()) %>% 
      pivot_wider(names_from = "clusterRes", values_from = "n") %>% 
      column_to_rownames(var = "batch")
    numb_cond1[is.na(numb_cond1)] <- 0
    numb_cond2[is.na(numb_cond2)] <- 0
    conf.mat <- table(simulation$trueLabels, Idents(simulation$integratedSamples))
    true.conf <- conf.mat/rowSums(conf.mat)
    library(clue)
    order2 = as.vector(solve_LSAP(true.conf, maximum = TRUE))
    L_sum1 = colSums(numb_cond1)
    L_sum2 = colSums(numb_cond2)
    decider = sum(L_sum1 > 10)+sum(L_sum2 > 10)
    if (decider == cluster_num*2) {   # if one cluster has least than 10 cells in one condition, then won't continue
      seurat_countL[[sim]] = list(cond1 = numb_cond1[,order2], cond2 = numb_cond2[,order2])
      
      ## Get matrices
      ### KNN matrix
      graphs = simulation$integratedSamples@graphs$RNA_snn
      labels = Idents(simulation$integratedSamples)
      knn_mat = knn_simMat(graphs, labels)
      order1 = colnames(numb_cond1)
      simil_matK = knn_mat[order1, order1]
      knn_matrixL[[sim]] = simil_matK
      ### True matrix
      simil_matT = true.conf[,order2]
      true_matrixL[[sim]] = simil_matT
      ### Uniform matrix
      simil_matU = create_simMat(cluster_num, confuse_rate=0.1)
      ### svm&rf
      mlDF = simulation$integratedSamples@reductions$pca@cell.embeddings %>% 
        as.data.frame() %>% 
        tibble::rownames_to_column("cellID") %>% 
        merge(simulation$dfRes, by = "cellID") %>% 
        dplyr::select(-cellID)
      set.seed(123)
      simil_matSVM = svm_simMat(mlDF)
      svm_matrixL[[sim]] = simil_matSVM
      
      ## Test
      ### DCATS---betabinLRT
      t1start = Sys.time()
      betabin_wBC_K = betabinLRT_rw(as.matrix(numb_cond1), as.matrix(numb_cond2), bias_corr = TRUE, similarity_mat = simil_matK)
      timeL[1] = Sys.time() - t1start
      ###  DCATS---betabinLRT with Bias correction from similarity matrix
      betabin_wBC_U = betabinLRT_rw(as.matrix(numb_cond1), as.matrix(numb_cond2), bias_corr = TRUE, similarity_mat = simil_matU)
      betabin_wBC_T = betabinLRT_rw(as.matrix(numb_cond1), as.matrix(numb_cond2), bias_corr = TRUE, similarity_mat = simil_matT)
      betabin_wBC_SVM = betabinLRT_rw(as.matrix(numb_cond1), as.matrix(numb_cond2), bias_corr = TRUE, similarity_mat = simil_matSVM)
      ## DCATS---betabin with similarity matrix (backward-forward)
      sim_count = rbind(numb_cond1, numb_cond2) %>% as.matrix()
      sim_design = data.frame(condition = c(rep("g1", rep1), rep("g2", rep2)))
      t2start = Sys.time()
      betabin_wMK = dcats_GLM(sim_count, sim_design, similarity_mat = simil_matK)
      timeL[2] = Sys.time() - t2start
      betabin_wMU = dcats_GLM(sim_count, sim_design, similarity_mat = simil_matU)
      betabin_wMT = dcats_GLM(sim_count, sim_design, similarity_mat = simil_matT)
      betabin_wMSVM = dcats_GLM(sim_count, sim_design, similarity_mat = simil_matSVM)
      ## DCATS---fix phi
      phi = getPhi(sim_count, sim_design)
      betabin_wPhiK = dcats_GLM(sim_count, sim_design, similarity_mat = simil_matK, fix_phi = phi)
      betabin_wPhiU = dcats_GLM(sim_count, sim_design, similarity_mat = simil_matU, fix_phi = phi)
      betabin_wPhiT = dcats_GLM(sim_count, sim_design, similarity_mat = simil_matT, fix_phi = phi)
      betabin_wPhiSVM = dcats_GLM(sim_count, sim_design, similarity_mat = simil_matSVM, fix_phi = phi)
      ## Fisher's exact test
      t3start = Sys.time()
      fisher_pvals = getFisher(as.matrix(numb_cond1), as.matrix(numb_cond2))
      timeL[3] = Sys.time() - t3start
      ## speckle
      t4start = Sys.time()
      speckleRes = propeller(clusters = simulation$dfRes$clusterRes, sample = simulation$dfRes$batch, group = simulation$dfRes$condition) %>% 
        dplyr::rename(cluster = BaselineProp.clusters,
                      speckle_pvals = FDR) %>%
        dplyr::select(cluster, speckle_pvals)
      timeL[4] = Sys.time() - t4start
      ## diffcyt
      t5start = Sys.time()
      diffcytP = getDiffcyt(numb_cond1, numb_cond2, simulation$dfRes)
      timeL[5] = Sys.time() - t5start
      ## scDC
      t6start = Sys.time()
      res_scDC <- scDC_noClustering(cellTypes = simulation$dfRes$clusterRes, simulation$dfRes$batch, calCI = TRUE, calCI_method = c("percentile", "BCa", "multinom"),nboot = 1000, verbose = FALSE)
      res_GLM <- fitGLM(res_scDC, c(rep("cond1",rep1*cluster_num),rep("cond2",rep2*cluster_num)), pairwise = FALSE, fixed_only = TRUE, verbose = FALSE)
      timeL[6] = Sys.time() - t6start
      scDCRes_temp = summary(res_GLM$pool_res_fixed)
      scDCRes = scDCRes_temp[c(cluster_num+1,(dim(scDCRes_temp)[1]-cluster_num+2):dim(scDCRes_temp)[1]),]
      
      ## results
      cluster_map = data.frame(cluster = colnames(numb_cond1[,order2]), truth = truthRes) %>% 
        arrange(cluster)
      all_res = cluster_map %>% 
        mutate(betabin_wBCK_pvals = betabin_wBC_K$pvals,
               betabin_wBCU_pvals = betabin_wBC_U$pvals,
               betabin_wBCT_pvals = betabin_wBC_T$pvals,
               betabin_wBCSVM_pvals = betabin_wBC_SVM$pvals,
               betabin_wMK_pvals = as.vector(betabin_wMK$LRT_pvals),
               betabin_wMU_pvals = as.vector(betabin_wMU$LRT_pvals),
               betabin_wMT_pvals = as.vector(betabin_wMT$LRT_pvals),
               betabin_wMSVM_pvals = as.vector(betabin_wMSVM$LRT_pvals),
               betabin_wPhiK_pvals = as.vector(betabin_wPhiK$LRT_pvals),
               betabin_wPhiU_pvals = as.vector(betabin_wPhiU$LRT_pvals),
               betabin_wPhiT_pvals = as.vector(betabin_wPhiT$LRT_pvals),
               betabin_wPhiSVM_pvals = as.vector(betabin_wPhiSVM$LRT_pvals),
               fisher_pvals = fisher_pvals,
               scDC_pvals = scDCRes$p.value) %>%
        merge(speckleRes, by = "cluster") %>% 
        merge(diffcytP, by = "cluster")
      simulationDF = rbind(simulationDF, all_res)
      time[sim,] = timeL
    }
  }
}

## send email after finishing
#sendEmail('Simulation is done!!')
```

```{r}
file_name = str_c("./data/simulationRES/replicates", as.character(rep1), "&", as.character(rep2), "_K", as.character(cluster_num), "_con", as.character(concentration), "_", cell_pool, more_negative, sample_size1, "&", sample_size2, ".RData")
colnames(time) = c("DCATS_wtoM", "DCATS_wM", "fisher", "speckle", "diffcyt", "scDC", "rfM", "svmM")
save(simulationDF, time, true_countL, seurat_countL, knn_matrixL, true_matrixL, file = file_name)
head(simulationDF, 15)
```














