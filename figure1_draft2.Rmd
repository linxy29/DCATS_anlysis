---
title: "Figure1 Draft"
output: html_document
---

```{r,message=FALSE,warning=FALSE}
library(splatter)
library(Seurat)
library(speckle)
library(DCATS)
library(ggplot2)
library(tidyverse)
library(MCMCpack)
library(pROC)
```

```{r}
source("functionsV2.r")
options(future.globals.maxSize = 20000 * 1024^2) # 20G memory
```

```{r}
theme_set(theme_classic()+
    theme(panel.border = element_blank(),
          legend.key = element_blank(),
          axis.ticks = element_blank(),
          panel.grid = element_blank(),
          panel.grid.minor = element_blank(), 
          panel.grid.major = element_blank(),
          panel.background = element_blank(),
          legend.background = element_blank(),
          plot.background = element_rect(fill = "transparent",colour = NA))+
      theme(axis.text=element_text(size=12),
        axis.title=element_text(size=14)))
```

```{r}
cluster_num = 3  # numbers of clusters
concentration = 70 # indicate how simulated proportion far away from true, the larger the closer
#rep1 = 3
rep1 = 2
rep2 = 3
#rep2 = 4
simulation_times = 20
simulation_size = 50
sample_size1 = 1000
sample_size2 = 2000

probC1 = c(1/3, 1/3, 1/3)  # True proportions
probC2 = c(1/3, 1/2, 1/6)
truthRes = c("N", "P", "P")
```

Function use to calculate fisher with boostrap

```{r}
getFisher_bs = function(counts1, counts2, similarity_mat=NULL, n_samples=50, pseudo_count=NULL) {
  ## bootstrap
  prop1 <- counts1 / rowSums(counts1)
  prop2 <- counts2 / rowSums(counts2)
  
  ## using estimated the latent cell counts
  counts1_latent = counts1
  counts2_latent = counts2
  if(!is.null(similarity_mat)) {
    for (i in seq_len(nrow(counts1))) {
      counts1_latent[i, ] <- sum(counts1[i, ]) * multinom_EM(counts1[i, ], similarity_mat, verbose = FALSE)$mu
      }
    for (i in seq_len(nrow(counts2))) {
      counts2_latent[i, ] <- sum(counts2[i, ]) * multinom_EM(counts2[i, ], similarity_mat, verbose = FALSE)$mu
    }
    }
  
  ## number of cell types
  K <- ncol(counts1)
  if (is.null(similarity_mat)) {
    n_samples <- 1
    }
  
  if (!is.null(n_samples) && !is.null(similarity_mat)) {
    counts1_use <- matrix(0, nrow(counts1) * n_samples, K)
    counts2_use <- matrix(0, nrow(counts2) * n_samples, K)
    for (i in seq_len(nrow(counts1))) {
      idx <- seq((i - 1) * n_samples + 1, i * n_samples)
      for (j in seq_len(K)) {
        counts1_use[idx, ] <- (
          counts1_use[idx, ] + t(rmultinom(n_samples,counts1_latent[i, j], similarity_mat[j, ])))
      }
      }
    for (i in seq_len(nrow(counts2))) {
      idx <- seq((i - 1) * n_samples + 1, i * n_samples)
      for (j in seq_len(K)) {
        counts2_use[idx, ] <- (
          counts2_use[idx, ] + t(rmultinom(n_samples,counts2_latent[i, j], similarity_mat[j, ])))
      }
      }
    } else{
      counts1_use <- counts1
      counts2_use <- counts2
      }

    # adding pseudo counts
    if (is.null(pseudo_count)) {
        if (any(colMeans(counts1) == 0) || any(colMeans(counts2) == 0) ) {
            print(paste("Empty cell type exists in at least one conidtion;", "adding replicate & condition specific pseudo count:"))
          counts1_use <- counts1_use + 1
          counts2_use <- counts2_use + 1
          }
      } else {
        counts1_use = counts1_use + pseudo_count
        counts2_use = counts2_use + pseudo_count
    }
    
  ## fisher test
  fisher_pval <- matrix(NA, n_samples, K)
  for (ir in seq_len(n_samples)) {           ## for each sampling
    idx1 <- seq(1, nrow(counts1_use), n_samples) + ir - 1
    idx2 <- seq(1, nrow(counts2_use), n_samples) + ir - 1
    fisher_pval[ir,] = getFisher(counts1_use[idx1,], counts2_use[idx2,])
  }
  
  return(fisher_pval)
}
```

Try used the complete version of dcats without fixed phi

```{r}
set.seed(123)

simulationDF_list = vector(mode = "list", length = simulation_times)
phiDF = data.frame()
for (sim in 1:simulation_times) {
  simulationDF = data.frame()
  for (simsim in 1:simulation_size){
    print(str_c("sim: ", as.character(sim), "simsim: ", as.character(simsim)))
    ## create confusion matrix that is not uniformly distributed
    simil_mat = matrix(c(1, 0, 0, 0, 0.7, 0.3, 0, 0.3, 0.7), ncol = 3)
    
    ## Data generation part
    totals1 = ceiling(runif(rep1, sample_size1, sample_size2))
    totals2 = ceiling(runif(rep2, sample_size1, sample_size2))
    diri_s1 = probC1 * concentration
    diri_s2 = probC2 * concentration
    sim_dat <- DCATS::simulator_base(totals1, totals2, diri_s1, diri_s2, simil_mat)
    numb_cond1 = as.matrix(sim_dat$numb_cond1)
    numb_cond2 = as.matrix(sim_dat$numb_cond2)
    
    ## Test part 1
    ### DCATS
    count_mat = rbind(numb_cond1, numb_cond2)
    design_df = data.frame(condition = c(rep("c1", rep1), rep("c2", rep2)))
    estphi1 = getPhi(count_mat, design_df)
    #avrgPhi = getPhi2(count_mat, design_df)$avrgPhi
    #adjPhi = getPhi2(count_mat, design_df)$adjPhiV
    wtoPhi_res1 = dcats_GLM(count_mat, design_df)
    estPhi_res1 = dcats_GLM(count_mat, design_df, fix_phi = estphi1)
    eachPhi1 = eachPhi(count_mat, design_df)$fm0_phi %>% rowMeans()
    #estPhi_res1 = dcats_GLM(count_mat, design_df, phi = rep(phi, cluster_num))
    #avrgPhi_res1 = dcats_GLM(count_mat, design_df, phi = rep(avrgPhi, cluster_num))
    #adjPhi_res1 = dcats_GLM(count_mat, design_df, phi = adjPhi)
    ### fisher
    fisher_pvals1 = getFisher(numb_cond1, numb_cond2)
    
    ## Test part 2 - only use EM
    ## Bias Correction
    numb_cond1BC = numb_cond1
    numb_cond2BC = numb_cond2
    for (i in seq_len(nrow(numb_cond1))) {
      numb_cond1BC[i, ] <- sum(numb_cond1[i, ]) * multinom_EM(numb_cond1[i, ], simil_mat, verbose = FALSE)$mu
      numb_cond1BC[i, ] = ceiling(numb_cond1BC[i, ])}
    for (i in seq_len(nrow(numb_cond2))) {
      numb_cond2BC[i, ] <- sum(numb_cond2[i, ]) * multinom_EM(numb_cond2[i, ], simil_mat, verbose = FALSE)$mu
      numb_cond2BC[i, ] = ceiling(numb_cond2BC[i, ])}
    
    
    ### DCATS
    countBC_mat = rbind(numb_cond1BC, numb_cond2BC)
    estphi2 = getPhi(countBC_mat, design_df)
    wtoPhi_res2 = dcats_GLM(countBC_mat, design_df)
    estPhi_res2 = dcats_GLM(countBC_mat, design_df, fix_phi = estphi2)
    eachPhi2 = eachPhi(countBC_mat, design_df)$fm0_phi %>% rowMeans()
    #estPhi_res2 = dcats_GLM(countBC_mat, design_df, phi = rep(phi, cluster_num))
    #avrgPhi_res2 = dcats_GLM(countBC_mat, design_df, phi = rep(avrgPhi, cluster_num))
    #adjPhi_res2 = dcats_GLM(countBC_mat, design_df, phi = adjPhi)
    ### fisher
    fisher_pvals2 = getFisher(numb_cond1BC, numb_cond2BC)
    
    ## use estPhi2 and numb_cond
    estPhi_res3 = dcats_GLM(count_mat, design_df, fix_phi = estphi2)
    
    all_res = data.frame(cluster = c("A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L")[1:cluster_num], truth = truthRes) %>%
      mutate(wtoPhi_null = as.vector(wtoPhi_res1$LRT_pvals),
             estPhi_null = as.vector(estPhi_res1$LRT_pvals),
             #avrgPhi_null = avrgPhi_res1$LRT_pvals,
             #adjPhi_null = adjPhi_res1$LRT_pvals,
             fisher_null = fisher_pvals1,
             wtoPhi_withBC = as.vector(wtoPhi_res2$LRT_pvals),
             estPhi_withBC = as.vector(estPhi_res2$LRT_pvals),
             #avrgPhi_withBC = avrgPhi_res2$LRT_pvals,
             #adjPhi_withBC = adjPhi_res2$LRT_pvals,
             fisher_withBC = fisher_pvals2,
             estPhi_test = as.vector(estPhi_res3$LRT_pvals))
    
    simulationDF = rbind(simulationDF, all_res)
    
    sub_phiDF = data.frame(sim = str_c(as.character(sim), "_", as.character(simsim)), cluster = c("A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L")[1:cluster_num], truth = truthRes, estPhi1 = estphi1, eachPhi1 = eachPhi1, estPhi2 = estphi2, eachPhi2 = eachPhi2)
    
    phiDF = rbind(phiDF, sub_phiDF)
    }
  simulationDF_list[[sim]] = simulationDF
}
#save(simulationDF_list, phiDF, file = "D:/Data/DCATS/simulation/toy_simulation.RData")
```

```{r}
#load("D:/Data/DCATS/simulation/simulationDF_list.RData")
evaluationDF = data.frame()
len = length(simulationDF_list)
#for (j in 1:8){
for (j in 1:len){
  simulationDF = simulationDF_list[[j]] %>% na.omit()
  method = colnames(simulationDF)[3:dim(simulationDF)[2]]
  numb_mthd = length(method)
  sensitivity = rep(NA, numb_mthd)
  specificity = rep(NA, numb_mthd)
  mcc = rep(NA, numb_mthd)
  auc = rep(NA, numb_mthd)
  prauc = rep(NA, numb_mthd)
  F1 = rep(NA, numb_mthd)
  
  truth = simulationDF$truth
  for (i in 3:dim(simulationDF)[2]){
    pred = simulationDF[, i]
    pred_res = ifelse(pred < 0.05, "P", "N")
    TP <- sum(pred_res=="P"&truth=="P")
    TN <- sum(pred_res=="N"&truth=="N")
    FP <- sum(pred_res=="P"&truth=="N")
    FN <- sum(pred_res=="N"&truth=="P")
    truthN = TN + FP
    truthP = FN + TP
    predP = TP + FP
    predN = FN + TN
    sensitivity[i-2] = TP/truthP
    specificity[i-2] = TN/truthN
    mcc[i-2] = (TP*TN-FP*FN)/sqrt(predP*truthP*truthN*predN)
    auc[i-2] = getROC(truth, pred)$auc
    prauc[i-2] = getPRC(truth, pred)$prauc
    F1 = 2*TP/(2*TP+FP+FN)
    
    res = data.frame(trial = as.character(j), method = method, sensitivity = sensitivity, specificity = specificity, mcc = mcc, auc = auc, prauc = prauc, F1 = F1)
    }
    evaluationDF = rbind(evaluationDF, res)
}
```

Plots

```{r}
evaluationDF %>% 
  tidyr::separate(method, c("method", "condition"), sep = "_") %>% 
  filter(condition != "full") %>% 
  pivot_longer(
    sensitivity:specificity,
    names_to = "statistics", 
    values_to = "value") %>% 
  #mutate(condition = ifelse(condition == "withBC", "with Bias Correction", "without Bias Correction"),
         #condition = factor(condition, levels = c("without Bias Correction", "with Bias Correction"))) %>%
  #mutate(method = ifelse(method == "dcats", "DCATS", "Fisher")) %>% 
  ggplot(aes(x = statistics, y = value, color = method)) + geom_boxplot() + facet_grid(.~condition) +
    theme(axis.title.x = element_blank())
  #ggplot(aes(x = statistics, y = value, color = method)) + geom_boxplot()
#ggsave("./plot/figureA2.png", bg = "transparent")
```

```{r}
evaluationDF %>% 
  tidyr::separate(method, c("method", "condition"), sep = "_") %>% 
  dplyr::select(-sensitivity, -specificity) %>% 
  filter(condition != "full") %>% 
  #mutate(method = ifelse(method == "dcats", "DCATS", "Fisher")) %>% 
  #mutate(condition = factor(condition, levels = c("wtoBC", "withBC"))) %>% 
  ggplot(aes(x = condition, y = auc, color = method)) + geom_boxplot() +
  theme(axis.title.x = element_blank(),
        legend.position = "top")
#ggsave("C:/#Code/R/slides/image/RPG_discussion/dcats_result1.png", bg = "transparent")
```

```{r}
evaluationDF %>% 
  tidyr::separate(method, c("method", "condition"), sep = "_") %>% 
  filter(condition != "full") %>% 
  #mutate(method = ifelse(method == "dcats", "DCATS", "Fisher")) %>% 
  #mutate(condition = factor(condition, levels = c("wtoBC", "withBC"))) %>% 
  ggplot(aes(x = condition, y = prauc, color = method)) + geom_boxplot() +
  theme(axis.title.x = element_blank(),
        legend.position = "top")
#ggsave("C:/#Code/R/slides/image/RPG_discussion/dcats_result1.png", bg = "transparent")
```

```{r}
phiDF %>% 
  ggplot(aes(x = eachPhi1, y = estPhi1)) +
  geom_point(aes(col = cluster))
phiDF %>% 
  ggplot(aes(x = eachPhi2, y = estPhi2)) +
  geom_point(aes(col = cluster))
phiDF %>% 
  ggplot(aes(x = eachPhi1, y = eachPhi2)) +
  geom_point(aes(col = cluster))
phiDF %>% 
  ggplot(aes(x = estPhi1, y = estPhi2)) +
  geom_point(aes(col = cluster))
```


## Add simple gene expression information

```{r, message=FALSE, warning=FALSE}
library(Seurat)
library(SeuratWrappers)
library(speckle)
library(DCATS)
library(ggplot2)
library(tidyverse)
library(diffcyt)
library(MCMCpack)
library(scdney)
library(tidymodels)  ## for DCATS
```

```{r}
cluster_num = 8  # numbers of clusters
concentration = 100 # indicate how simulated proportion far away from true, the larger the closer
setresolu = 0.7
rep1 = 3
rep2 = 3
simulation_times = 30
sample_size1 = 1500
sample_size2 = 2500
cell_pool = "splatter"  # cell pool used, can be selected from ("SPAR", "splatter", "realWorld")
more_negative = ""
```

```{r}
if(cluster_num == 8){
  probC1 = c(rep(0.1, 6), 0.2, 0.2)  # True proportions
  probC2 = c(rep(0.1, 3), 0.05, 0.15, 0.2, 0.2, 0.1)
  truthRes = c(rep("N", 3), rep("P", 3), "N", "P")
} else if (cluster_num == 10){
  probC1 = c(rep(0.1, 5), 0.05, 0.05, 0.05, 0.2, 0.15)  # True proportions
  probC2 = c(rep(0.1, 10))
  truthRes = c(rep("N", 5), rep("P", 5))
} else if (cluster_num == 12){
  probC1 = c(rep(0.1, 4), 0.05, 0.05, 0.05, 0.15, 0.05, 0.05, 0.1, 0.1)  # True proportions
  probC2 = c(rep(0.1, 8), rep(0.05, 4))
  truthRes = c(rep("N", 4), rep("P", 4), "N", "N", "P", "P")
} else {
  print("Not pre-set clutser number")
}
```

```{r, message=FALSE, warning=FALSE}
source("functionsV2.r")
source("glm.R")     # for scDC
options(future.globals.maxSize = 15000 * 1024^2)
```

```{r}
if (cell_pool == "splatter"){
  load(str_c("D:/Data/DCATS/cells_pool", as.character(cluster_num), "_splatter.RData"))
  #load(str_c("D:/Data/DCATS/cells_pool", as.character(cluster_num), "_splatter_test.RData"))
} else if (cell_pool == "SPAR") {
    load(str_c("D:/Data/DCATS/cells_pool", as.character(cluster_num), "_SPARSim.RData"))
  
} else if (cell_pool == "realWorld") {
    load(str_c("D:/Data/DCATS/cells_pool", as.character(cluster_num), "_realWorld.RData"))
}
```

```{r}
simulator_propM = function(totalV, prop_mat, setresolu, sim_mat){
  K = ncol(prop_mat)
  prop_sim = matrix(NA, nrow = nrow(prop_mat), ncol = ncol(prop_mat))
  numb_sim = matrix(NA, nrow = nrow(prop_mat), ncol = ncol(prop_mat))
  
  # cell selection
  slt_sim_mat = matrix(NA, ncol = 0, nrow = dim(sim_mat)[1])
  slt_origLabels = vector()
  slt_batches = character()
  for (rep in 1:nrow(prop_mat)) {
    prop_sim[rep, ] <- MCMCpack::rdirichlet(1, prop_mat[rep,] * concentration)
    numb_sim[rep, ] <- rmultinom(1, totalV[rep], prop_sim[rep, ])
    cell_slt = cell_slt_dup(numb_sim[rep, ], sim_mat, origLabels)
    slt_sim_mat = cbind(slt_sim_mat, cell_slt$sub_sim_mat)
    slt_origLabels = c(slt_origLabels, cell_slt$sub_origLabels)
    slt_batches = c(slt_batches, rep(str_c("rep", as.character(rep)), length(cell_slt$sub_origLabels)))
  }
  
  print(numb_sim)
  
  ## seurat process
  ### pre-process
  seuratObj <- CreateSeuratObject(counts = slt_sim_mat, project="Splatter")
  seuratObj <- AddMetaData(object = seuratObj, metadata = slt_batches, col.name = 'batch')
  seuratObj <- NormalizeData(seuratObj, verbose = FALSE)
  #integratedSamples <- RunFastMNN(object.list = SplitObject(seuratObj, split.by = "batch"), verbose = FALSE)
  integratedSamples <- FindVariableFeatures(seuratObj, verbose = FALSE)
  integratedSamples <- ScaleData(integratedSamples, verbose = FALSE)
  integratedSamples <- RunPCA(integratedSamples, npcs = 30, verbose = FALSE, features = VariableFeatures(object = integratedSamples))
  #integratedSamples <- RunUMAP(integratedSamples, reduction = "mnn", dims = 1:30, verbose = FALSE)
  #integratedSamples <- FindNeighbors(integratedSamples, reduction = "mnn", dims = 1:30, verbose = FALSE)
  integratedSamples <- RunUMAP(integratedSamples, dims = 1:30, verbose = FALSE)
  integratedSamples <- FindNeighbors(integratedSamples, dims = 1:30, verbose = FALSE)
  integratedSamples <- FindClusters(integratedSamples, resolution = setresolu, verbose = FALSE)
  
  ## decide resolution
  Kprep = integratedSamples@active.ident %>% as.factor() %>% summary() %>% length()
  str_c("Kprep: ", as.character(Kprep)) %>% print()
  str_c("setresolu: ", as.character(setresolu)) %>% print()
  while (Kprep != K & setresolu > 0.03) {
    if (Kprep > K){
      setresolu = setresolu - 0.03
      integratedSamples <- FindClusters(integratedSamples, resolution = setresolu, verbose = FALSE)
      Kprep = integratedSamples@active.ident %>% as.factor() %>% summary() %>% length()
      str_c("Kprep: ", as.character(Kprep)) %>% print()
      str_c("setresolu: ", as.character(setresolu)) %>% print()
    } else {
      setresolu = setresolu + 0.01
      integratedSamples <- FindClusters(integratedSamples, resolution = setresolu, verbose = FALSE)
      Kprep = integratedSamples@active.ident %>% as.factor() %>% summary() %>% length()
      str_c("Kprep: ", as.character(Kprep)) %>% print()
      str_c("setresolu: ", as.character(setresolu)) %>% print()
    }
  }
  ### change labels to A, B, C
  integratedSamples@active.ident = integratedSamples@active.ident %>% 
    plyr::mapvalues(from = c(0:15), to = c("A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P"))
  
  # get count data
  dfRes = data.frame(clusterRes = integratedSamples@active.ident, batch = integratedSamples$batch) %>% 
    tibble::rownames_to_column("cellID")
  if(Kprep == K){
    Res = list(integratedSamples = integratedSamples, dfRes = dfRes, trueLabels = slt_origLabels, numb_sim = numb_sim, prop_sim = prop_sim)
    return(Res)
  } else {
    return(NA)
  }

}
```

```{r}
prob = rep(1/cluster_num, cluster_num)
batch_size = cluster_num * 1500
de_prob = rep(NA, cluster_num)
de_prob[1:round(cluster_num/2)] = runif(round(cluster_num/2), 0.1, 0.2)
de_prob[(round(cluster_num/2)+1):cluster_num] = runif((cluster_num - round(cluster_num/2)), 0.5, 1)
params = readRDS("D:/Data/DCATS/simulation/mnnCT7params.rds")
```

Following is the code to simulate gene expression but not select cells. Doesn't work

```{r, eval=FALSE}
simulator_splatter = function(totalV, prop_mat, setresolu) {
  K = ncol(prop_mat)
  prop_sim = matrix(NA, nrow = nrow(prop_mat), ncol = ncol(prop_mat))
  numb_sim = matrix(NA, nrow = nrow(prop_mat), ncol = ncol(prop_mat))
  
  # cell selection
  slt_sim_mat = matrix(NA, ncol = 0, nrow = dim(sim_mat)[1])
  slt_origLabels = vector()
  slt_batches = character()
  for (rep in 1:nrow(prop_mat)) {
    prop_sim[rep, ] <- MCMCpack::rdirichlet(1, prop_mat[rep,] * concentration)
    numb_sim[rep, ] <- rmultinom(1, totalV[rep], prop_sim[rep, ])
    de_prob = rep(NA, cluster_num)
    de_prob[1:round(cluster_num/2)] = runif(round(cluster_num/2), 0.1, 0.2)
    de_prob[(round(cluster_num/2)+1):cluster_num] = runif((cluster_num - round(cluster_num/2)), 0.5, 1)
    param.groups <- setParams(params, batchCells = numb_sim[rep, ], nGenes = 1000)
    sim <- splatSimulateGroups(param.groups, group.prob = prob, de.prob = de_prob, de.facLoc = 0.01, verbose = FALSE)
    sub_sim_mat <- counts(sim)
    colnames(sub_sim_mat) = colnames(sub_sim_mat) %>% str_c(str_c("_batch", as.character(rep)))
    sub_origLabels = sim@colData@listData$Group
    slt_sim_mat = cbind(slt_sim_mat, sub_sim_mat)
    slt_origLabels = c(slt_origLabels, sub_origLabels)
    slt_batches = c(slt_batches, rep(str_c("rep", as.character(rep)), length(sub_origLabels)))
  }
  
  print(numb_sim)
  
  ## seurat process
  ### pre-process
  seuratObj <- CreateSeuratObject(counts = slt_sim_mat, project="Splatter")
  seuratObj <- AddMetaData(object = seuratObj, metadata = slt_batches, col.name = 'batch')
  seuratObj <- NormalizeData(seuratObj, verbose = FALSE)
  seuratObj <- FindVariableFeatures(seuratObj, verbose = FALSE)
  #integratedSamples <- RunFastMNN(object.list = SplitObject(seuratObj, split.by = "batch"), verbose = FALSE)
  integratedSamples <- ScaleData(seuratObj, verbose = FALSE)
  integratedSamples <- RunPCA(integratedSamples, npcs = 30, verbose = FALSE, features = VariableFeatures(object = integratedSamples))
  #integratedSamples <- RunUMAP(integratedSamples, reduction = "mnn", dims = 1:30, verbose = FALSE)
  #integratedSamples <- FindNeighbors(integratedSamples, reduction = "mnn", dims = 1:30, verbose = FALSE)
  integratedSamples <- RunUMAP(integratedSamples, dims = 1:30, verbose = FALSE)
  integratedSamples <- FindNeighbors(integratedSamples, dims = 1:30, verbose = FALSE)
  integratedSamples <- FindClusters(integratedSamples, resolution = setresolu, verbose = FALSE)
  
  ## decide resolution
  Kprep = integratedSamples@active.ident %>% as.factor() %>% summary() %>% length()
  str_c("Kprep: ", as.character(Kprep)) %>% print()
  str_c("setresolu: ", as.character(setresolu)) %>% print()
  while (Kprep != K & setresolu > 0.03) {
    if (Kprep > K){
      setresolu = setresolu - 0.03
      integratedSamples <- FindClusters(integratedSamples, resolution = setresolu, verbose = FALSE)
      Kprep = integratedSamples@active.ident %>% as.factor() %>% summary() %>% length()
      str_c("Kprep: ", as.character(Kprep)) %>% print()
      str_c("setresolu: ", as.character(setresolu)) %>% print()
    } else {
      setresolu = setresolu + 0.01
      integratedSamples <- FindClusters(integratedSamples, resolution = setresolu, verbose = FALSE)
      Kprep = integratedSamples@active.ident %>% as.factor() %>% summary() %>% length()
      str_c("Kprep: ", as.character(Kprep)) %>% print()
      str_c("setresolu: ", as.character(setresolu)) %>% print()
    }
  }
  ### change labels to A, B, C
  integratedSamples@active.ident = integratedSamples@active.ident %>% 
    plyr::mapvalues(from = c(0:15), to = c("A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P"))
  
  # get count data
  dfRes = data.frame(clusterRes = integratedSamples@active.ident, batch = integratedSamples$batch) %>% 
    tibble::rownames_to_column("cellID")
  if(Kprep == K){
    Res = list(integratedSamples = integratedSamples, dfRes = dfRes, trueLabels = slt_origLabels, numb_sim = numb_sim, prop_sim = prop_sim)
    return(Res)
  } else {
    return(NA)
  }
}
```

```{r, message=FALSE, warning=FALSE, echo=FALSE}
## output data
simulationDF = data.frame()  # data frame to store test result
time = matrix(NA, nrow = simulation_times, ncol = 8) # matrix contains time for each test need in each simulation and time need to calculate svm/rf matrix
true_countL = vector(mode = "list", length = simulation_times) # list contains the count table of each true cluster
seurat_countL = vector(mode = "list", length = simulation_times) # list contains the count table of each cluster defined by seurat
knn_matrixL = vector(mode = "list", length = simulation_times) # list contains the knn matrix getting from each simulation
true_matrixL = vector(mode = "list", length = simulation_times) # list contains the true similarity matrix getting from each simulation
rf_matrixL = vector(mode = "list", length = simulation_times) # list contains the knn matrix getting from each simulation
svm_matrixL = vector(mode = "list", length = simulation_times) # list contains the true similarity matrix getting from each simulation

set.seed(1)
for (sim in 1:simulation_times){
  print(sim)
  timeL = rep(NA, 8) # DCATS w/wto similarity matrix, fisher, speckle, diffcyt, scDC
  ## simulation
  simulation = simulator_fastMNN(totals1 = runif(rep1, sample_size1, sample_size2), totals2 = runif(rep2, sample_size1, sample_size2), probC1, probC2, setresolu, sim_mat)
  if (is.na(simulation)[1] == FALSE){
    true_countL[[sim]] = c(cond1 = simulation$numb_cond1, cond2 = simulation$numb_cond2)
    
    ## data convert
    numb_cond1 = simulation$dfRes %>% 
      filter(condition == "Cond1") %>%
      group_by(clusterRes, batch) %>% 
      summarise(n = n()) %>% 
      pivot_wider(names_from = "clusterRes", values_from = "n") %>% 
      column_to_rownames(var = "batch")
    numb_cond2 = simulation$dfRes %>% 
      filter(condition == "Cond2") %>%
      group_by(clusterRes, batch) %>% 
      summarise(n = n()) %>% 
      pivot_wider(names_from = "clusterRes", values_from = "n") %>% 
      column_to_rownames(var = "batch")
    numb_cond1[is.na(numb_cond1)] <- 0
    numb_cond2[is.na(numb_cond2)] <- 0
    conf.mat <- table(simulation$trueLabels, Idents(simulation$integratedSamples))
    true.conf <- conf.mat/rowSums(conf.mat)
    
    #print(numb_cond1)
    #print(numb_cond2)
    
    library(clue)
    order2 = as.vector(solve_LSAP(true.conf, maximum = TRUE))
    L_sum1 = colSums(numb_cond1)
    L_sum2 = colSums(numb_cond2)
    decider = sum(L_sum1 > 10)+sum(L_sum2 > 10)
    if (decider == cluster_num*2) {   # if one cluster has least than 10 cells in one condition, then won't continue
      seurat_countL[[sim]] = list(cond1 = numb_cond1[,order2], cond2 = numb_cond2[,order2])
      
      ## Get matrices
      ### KNN matrix
      graphs = simulation$integratedSamples@graphs$RNA_snn
      labels = Idents(simulation$integratedSamples)
      knn_mat = knn_simMat(graphs, labels)
      order1 = colnames(numb_cond1)
      simil_matK = knn_mat[order1, order1]
      knn_matrixL[[sim]] = simil_matK
      ### True matrix
      simil_matT = true.conf[,order2]
      true_matrixL[[sim]] = simil_matT
      ### Uniform matrix
      simil_matU = create_simMat(cluster_num, confuse_rate=0.1)
      ### svm&rf
      mlDF = simulation$integratedSamples@reductions$pca@cell.embeddings %>% 
        as.data.frame() %>% 
        tibble::rownames_to_column("cellID") %>% 
        merge(simulation$dfRes, by = "cellID") %>% 
        dplyr::select(-cellID)
      set.seed(123)
      simil_matSVM = svm_simMat(mlDF)
      svm_matrixL[[sim]] = simil_matSVM
      print(simil_matSVM)
      
      ## Test
      ### DCATS---betabinLRT
      sim_count = rbind(numb_cond1, numb_cond2) %>% as.matrix()
      sim_design = data.frame(condition = c(rep("g1", rep1), rep("g2", rep2)))
      t1start = Sys.time()
      betabin_null = dcats_GLM(sim_count, sim_design)
      timeL[1] = Sys.time() - t1start
      ###  DCATS---betabinLRT with Bias correction from similarity matrix
      phi = getPhi(sim_count, sim_design)
      #avrgPhi = getPhi2(sim_count, sim_design)$avrgPhi
      #adjPhi = getPhi2(sim_count, sim_design)$adjPhiV
      estPhi_null = dcats_GLM(sim_count, sim_design, fix_phi = phi)
      #avrgPhi_null = dcats_GLM(sim_count, sim_design, phi = rep(avrgPhi, cluster_num))
      #adjPhi_null = dcats_GLM(sim_count, sim_design, phi = adjPhi)
      numb_cond1 = numb_cond1 %>% as.matrix()
      numb_cond2 = numb_cond2 %>% as.matrix()
      ## KNN
      numb_cond1BC = numb_cond1
      numb_cond2BC = numb_cond2
      for (i in seq_len(nrow(numb_cond1))) {
        numb_cond1BC[i, ] <- sum(numb_cond1[i, ]) * multinom_EM(numb_cond1[i, ], simil_matK, verbose = FALSE)$mu
        numb_cond1BC[i, ] = ceiling(numb_cond1BC[i, ])}
      for (i in seq_len(nrow(numb_cond2))) {
        numb_cond2BC[i, ] <- sum(numb_cond2[i, ]) * multinom_EM(numb_cond2[i, ], simil_matK, verbose = FALSE)$mu
        numb_cond2BC[i, ] = ceiling(numb_cond2BC[i, ])}
      countBC_mat = rbind(numb_cond1BC, numb_cond2BC)
      wtoPhi_emK = dcats_GLM(countBC_mat, sim_design)
      estPhi_emK = dcats_GLM(countBC_mat, sim_design, fix_phi = phi)
      #avrgPhi_emK = dcats_GLM(countBC_mat, sim_design, phi = rep(avrgPhi, cluster_num))
      #adjPhi_emK = dcats_GLM(countBC_mat, sim_design, phi = adjPhi)
      ## Uniform
      numb_cond1BC = numb_cond1
      numb_cond2BC = numb_cond2
      for (i in seq_len(nrow(numb_cond1))) {
        numb_cond1BC[i, ] <- sum(numb_cond1[i, ]) * multinom_EM(numb_cond1[i, ], simil_matU, verbose = FALSE)$mu
        numb_cond1BC[i, ] = ceiling(numb_cond1BC[i, ])}
      for (i in seq_len(nrow(numb_cond2))) {
        numb_cond2BC[i, ] <- sum(numb_cond2[i, ]) * multinom_EM(numb_cond2[i, ], simil_matU, verbose = FALSE)$mu
        numb_cond2BC[i, ] = ceiling(numb_cond2BC[i, ])}
      countBC_mat = rbind(numb_cond1BC, numb_cond2BC) %>% as.matrix()
      wtoPhi_emU = dcats_GLM(countBC_mat, sim_design)
      estPhi_emU = dcats_GLM(countBC_mat, sim_design, fix_phi = phi)
      #avrgPhi_emU = dcats_GLM(countBC_mat, sim_design, phi = rep(avrgPhi, cluster_num))
      #adjPhi_emU = dcats_GLM(countBC_mat, sim_design, phi = adjPhi)
      ## True
      numb_cond1BC = numb_cond1
      numb_cond2BC = numb_cond2
      for (i in seq_len(nrow(numb_cond1))) {
        numb_cond1BC[i, ] <- sum(numb_cond1[i, ]) * multinom_EM(numb_cond1[i, ], simil_matT, verbose = FALSE)$mu
        numb_cond1BC[i, ] = ceiling(numb_cond1BC[i, ])}
      for (i in seq_len(nrow(numb_cond2))) {
        numb_cond2BC[i, ] <- sum(numb_cond2[i, ]) * multinom_EM(numb_cond2[i, ], simil_matT, verbose = FALSE)$mu
        numb_cond2BC[i, ] = ceiling(numb_cond2BC[i, ])}
      countBC_mat = rbind(numb_cond1BC, numb_cond2BC) %>% as.matrix()
      wtoPhi_emT = dcats_GLM(countBC_mat, sim_design)
      estPhi_emT = dcats_GLM(countBC_mat, sim_design, fix_phi = phi)
      #avrgPhi_emT = dcats_GLM(countBC_mat, sim_design, phi = rep(avrgPhi, cluster_num))
      #adjPhi_emT = dcats_GLM(countBC_mat, sim_design, phi = adjPhi)
      ## svm
      numb_cond1BC = numb_cond1
      numb_cond2BC = numb_cond2
      for (i in seq_len(nrow(numb_cond1))) {
        numb_cond1BC[i, ] <- sum(numb_cond1[i, ]) * multinom_EM(numb_cond1[i, ], simil_matSVM, verbose = FALSE)$mu
        numb_cond1BC[i, ] = ceiling(numb_cond1BC[i, ])}
      for (i in seq_len(nrow(numb_cond2))) {
        numb_cond2BC[i, ] <- sum(numb_cond2[i, ]) * multinom_EM(numb_cond2[i, ], simil_matSVM, verbose = FALSE)$mu
        numb_cond2BC[i, ] = ceiling(numb_cond2BC[i, ])}
      countBC_mat = rbind(numb_cond1BC, numb_cond2BC) %>% as.matrix()
      wtoPhi_emSVM = dcats_GLM(countBC_mat, sim_design)
      estPhi_emSVM = dcats_GLM(countBC_mat, sim_design, fix_phi = phi)
      #avrgPhi_emSVM = dcats_GLM(countBC_mat, sim_design, phi = rep(avrgPhi, cluster_num))
      #adjPhi_emSVM = dcats_GLM(countBC_mat, sim_design, phi = adjPhi)
      
      ## Fisher's exact test
      t3start = Sys.time()
      fisher_pvals = getFisher(as.matrix(numb_cond1), as.matrix(numb_cond2))
      timeL[3] = Sys.time() - t3start
      ## speckle
      t4start = Sys.time()
      speckleRes = propeller(clusters = simulation$dfRes$clusterRes, sample = simulation$dfRes$batch, group = simulation$dfRes$condition) %>% 
        dplyr::rename(cluster = BaselineProp.clusters,
                      speckle_pvals = FDR) %>%
        dplyr::select(cluster, speckle_pvals)
      timeL[4] = Sys.time() - t4start
      ## diffcyt
      t5start = Sys.time()
      diffcytP = getDiffcyt(numb_cond1, numb_cond2, simulation$dfRes)
      timeL[5] = Sys.time() - t5start
      ## scDC
      t6start = Sys.time()
      res_scDC <- scDC_noClustering(cellTypes = simulation$dfRes$clusterRes, simulation$dfRes$batch, calCI = TRUE, calCI_method = c("percentile", "BCa", "multinom"),nboot = 1000, verbose = FALSE)
      res_GLM <- fitGLM(res_scDC, c(rep("cond1",rep1*cluster_num),rep("cond2",rep2*cluster_num)), pairwise = FALSE, fixed_only = TRUE, verbose = FALSE)
      timeL[6] = Sys.time() - t6start
      scDCRes_temp = summary(res_GLM$pool_res_fixed)
      scDCRes = scDCRes_temp[c(cluster_num+1,(dim(scDCRes_temp)[1]-cluster_num+2):dim(scDCRes_temp)[1]),]
      
      ## results
      cluster_map = data.frame(cluster = colnames(numb_cond1[,order2]), truth = truthRes) %>% 
        arrange(cluster)
      all_res = cluster_map %>% 
        mutate(betabin_null_pvals = as.vector(betabin_null$LRT_pvals),
               estPhi_null_pvals = as.vector(estPhi_null$LRT_pvals),
               wtoPhi_emSVM_pvals = as.vector(wtoPhi_emSVM$LRT_pvals),
               estPhi_emSVM_pvals = as.vector(estPhi_emSVM$LRT_pvals),
               wtoPhi_emT_pvals = as.vector(wtoPhi_emT$LRT_pvals),
               estPhi_emT_pvals = as.vector(estPhi_emT$LRT_pvals),
               wtoPhi_emU_pvals = as.vector(wtoPhi_emU$LRT_pvals),
               estPhi_emU_pvals = as.vector(estPhi_emU$LRT_pvals),
               wtoPhi_emK_pvals = as.vector(wtoPhi_emK$LRT_pvals),
               estPhi_emK_pvals = as.vector(estPhi_emK$LRT_pvals),
               fisher_pvals = fisher_pvals,
               scDC_pvals = scDCRes$p.value) %>%
        merge(speckleRes, by = "cluster") %>% 
        merge(diffcytP, by = "cluster")
      simulationDF = rbind(simulationDF, all_res)
      time[sim,] = timeL
    }
  }
}

## send email after finishing
#sendEmail('Simulation is done!!')
```

```{r}
#file_name = str_c("D:/Data/DCATS/simulation/replicates", as.character(rep1), "&", as.character(rep2), "_K", as.character(cluster_num), "_con", as.character(concentration), "_", cell_pool, more_negative, sample_size1, "&", sample_size2, "_test.RData")
file_name = str_c("D:/Data/DCATS/simulation/replicates", as.character(rep1), "&", as.character(rep2), "_K", as.character(cluster_num), "_con", as.character(concentration), "_", cell_pool, more_negative, sample_size1, "&", sample_size2, ".RData")
colnames(time) = c("DCATS_wtoM", "DCATS_wM", "fisher", "speckle", "diffcyt", "scDC", "rfM", "svmM")
save(simulationDF, time, true_countL, seurat_countL, knn_matrixL, true_matrixL, file = file_name)
head(simulationDF, 15)
```

```{r}
load(file_name)
simulationDF = simulationDF %>% na.omit()
methods = colnames(simulationDF)[3:dim(simulationDF)[2]] %>% str_remove("_pvals")
numb_mthd = length(methods)
mcc = rep(NA, numb_mthd)
auc = rep(NA, numb_mthd)
prauc = rep(NA, numb_mthd)
sensitivity = rep(NA, numb_mthd)
specificity = rep(NA, numb_mthd)
precision = rep(NA, numb_mthd)
truth = simulationDF$truth
for (i in 3:dim(simulationDF)[2]){
  auc[i-2] = getROC(simulationDF$truth, simulationDF[,i])$auc
  pred = simulationDF[, i]
  pred_res = ifelse(pred < 0.05, "P", "N")
  TP <- sum(pred_res=="P"&truth=="P")
  TN <- sum(pred_res=="N"&truth=="N")
  FP <- sum(pred_res=="P"&truth=="N")
  FN <- sum(pred_res=="N"&truth=="P")
  truthN = TN + FP
  truthP = FN + TP
  predP = TP + FP
  predN = FN + TN
  mcc[i-2] = (TP*TN-FP*FN)/sqrt(predP*truthP*truthN*predN)
  prauc[i-2] = getPRC(simulationDF$truth, simulationDF[,i])$prauc
  sensitivity[i-2] = TP/truthP
  specificity[i-2] = TN/truthN
  precision[i-2] = TP/predP
}
res = data.frame(methods = methods, mcc = mcc, auc = auc, prauc = prauc, sensitivity = sensitivity, specificity = specificity, precision = precision) %>% 
  arrange(desc(auc)) %>% 
  #filter(methods == "wtoPhi_fullK" | methods == "diffcyt" | methods == "speckle" | methods == "fisher" | methods == "scDC")
print(res)
```

## Simulation with covariate

```{r}
## numbers of replicates for each condition: 15
condition = c(rep("cond1", 10), rep("cond2", 10))
gender = sample(c("female", "male"), 20, replace = TRUE)
age = sample(15:45, 20, replace = TRUE)
design_mat = data.frame(condition, gender, age)
## proportion contribution
prop_cond1 = rep(8,8)
prop_cond2 = c(6, 6, 10, 10, 8, 8, 8, 8)
#prop_gender = rep(c(-1, 1, 1, -1), 2)
prop_gender = rep(c(-2, 2, 0, 0), 2)
prop_age = c(-0.05, rep(0, 2), 0.05, 0.05, rep(0, 2), -0.05)
cond_mat = matrix(c(rep(prop_cond1, 10), rep(prop_cond2, 10)), nrow = 8) %>% t()
gender_mat = matrix(as.numeric(as.factor(gender))-1, ncol = 1) %*% prop_gender
age_mat = matrix(age-15, ncol = 1) %*% prop_age
add_mat = cond_mat + gender_mat + age_mat
prop_mat = add_mat/rowSums(add_mat)
```

```{r, eval=FALSE}
lm = design_mat %>% 
  mutate(y = prop_mat[,5]) %>% 
  lm(y~., data = .)
summary(lm)
lm = design_mat %>% 
  mutate(y = prop_mat[,4]) %>% 
  lm(y~., data = .)
summary(lm)
```

```{r}
cluster_num = 8  # numbers of clusters
concentration = 100 # indicate how simulated proportion far away from true, the larger the closer
setresolu = 0.6
simulation_times = 30
sample_size1 = 1500
sample_size2 = 2500
cell_pool = "splatter"  # cell pool used, can be selected from ("SPAR", "splatter", "realWorld")
more_negative = ""
truthRes = c(rep("P", 4), rep("N", 4))
```

```{r, message=FALSE, warning=FALSE}
source("functionsV2.r")
source("glm.R")     # for scDC
options(future.globals.maxSize = 15000 * 1024^2)
```

```{r}
if (cell_pool == "splatter"){
  load(str_c("D:/Data/DCATS/cells_pool", as.character(cluster_num), "_splatter.RData"))
  #load(str_c("D:/Data/DCATS/cells_pool", as.character(cluster_num), "_splatter_test.RData"))
} else if (cell_pool == "SPAR") {
    load(str_c("D:/Data/DCATS/cells_pool", as.character(cluster_num), "_SPARSim.RData"))
  
} else if (cell_pool == "realWorld") {
    load(str_c("D:/Data/DCATS/cells_pool", as.character(cluster_num), "_realWorld.RData"))
}
```

```{r}
simulator_propM = function(totalV, prop_mat, setresolu, sim_mat){
  K = ncol(prop_mat)
  prop_sim = matrix(NA, nrow = nrow(prop_mat), ncol = ncol(prop_mat))
  numb_sim = matrix(NA, nrow = nrow(prop_mat), ncol = ncol(prop_mat))
  
  # cell selection
  slt_sim_mat = matrix(NA, ncol = 0, nrow = dim(sim_mat)[1])
  slt_origLabels = vector()
  slt_batches = character()
  for (rep in 1:nrow(prop_mat)) {
    prop_sim[rep, ] <- MCMCpack::rdirichlet(1, prop_mat[rep,] * concentration)
    numb_sim[rep, ] <- rmultinom(1, totalV[rep], prop_sim[rep, ])
    cell_slt = cell_slt_dup(numb_sim[rep, ], sim_mat, origLabels)
    slt_sim_mat = cbind(slt_sim_mat, cell_slt$sub_sim_mat)
    slt_origLabels = c(slt_origLabels, cell_slt$sub_origLabels)
    slt_batches = c(slt_batches, rep(str_c("rep", as.character(rep)), length(cell_slt$sub_origLabels)))
  }
  
  print(numb_sim)
  
  ## seurat process
  ### pre-process
  seuratObj <- CreateSeuratObject(counts = slt_sim_mat, project="Splatter")
  seuratObj <- AddMetaData(object = seuratObj, metadata = slt_batches, col.name = 'batch')
  seuratObj <- NormalizeData(seuratObj, verbose = FALSE)
  #integratedSamples <- RunFastMNN(object.list = SplitObject(seuratObj, split.by = "batch"), verbose = FALSE)
  integratedSamples <- FindVariableFeatures(seuratObj, verbose = FALSE)
  integratedSamples <- ScaleData(integratedSamples, verbose = FALSE)
  integratedSamples <- RunPCA(integratedSamples, npcs = 30, verbose = FALSE, features = VariableFeatures(object = integratedSamples))
  #integratedSamples <- RunUMAP(integratedSamples, reduction = "mnn", dims = 1:30, verbose = FALSE)
  #integratedSamples <- FindNeighbors(integratedSamples, reduction = "mnn", dims = 1:30, verbose = FALSE)
  integratedSamples <- RunUMAP(integratedSamples, dims = 1:30, verbose = FALSE)
  integratedSamples <- FindNeighbors(integratedSamples, dims = 1:30, verbose = FALSE)
  integratedSamples <- FindClusters(integratedSamples, resolution = setresolu, verbose = FALSE)
  
  ## decide resolution
  Kprep = integratedSamples@active.ident %>% as.factor() %>% summary() %>% length()
  str_c("Kprep: ", as.character(Kprep)) %>% print()
  str_c("setresolu: ", as.character(setresolu)) %>% print()
  while (Kprep != K & setresolu > 0.03) {
    if (Kprep > K){
      setresolu = setresolu - 0.03
      integratedSamples <- FindClusters(integratedSamples, resolution = setresolu, verbose = FALSE)
      Kprep = integratedSamples@active.ident %>% as.factor() %>% summary() %>% length()
      str_c("Kprep: ", as.character(Kprep)) %>% print()
      str_c("setresolu: ", as.character(setresolu)) %>% print()
    } else {
      setresolu = setresolu + 0.01
      integratedSamples <- FindClusters(integratedSamples, resolution = setresolu, verbose = FALSE)
      Kprep = integratedSamples@active.ident %>% as.factor() %>% summary() %>% length()
      str_c("Kprep: ", as.character(Kprep)) %>% print()
      str_c("setresolu: ", as.character(setresolu)) %>% print()
    }
  }
  ### change labels to A, B, C
  integratedSamples@active.ident = integratedSamples@active.ident %>% 
    plyr::mapvalues(from = c(0:15), to = c("A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P"))
  
  # get count data
  dfRes = data.frame(clusterRes = integratedSamples@active.ident, batch = integratedSamples$batch) %>% 
    tibble::rownames_to_column("cellID")
  if(Kprep == K){
    Res = list(integratedSamples = integratedSamples, dfRes = dfRes, trueLabels = slt_origLabels, numb_sim = numb_sim, prop_sim = prop_sim)
    return(Res)
  } else {
    return(NA)
  }

}
```

```{r}
## output data
simulationDF = data.frame()  # data frame to store test result
simulationDF_age = data.frame()  # data frame to store test result
simulationDF_gender = data.frame()  # data frame to store test result
time = matrix(NA, nrow = simulation_times, ncol = 8) # matrix contains time for each test need in each simulation and time need to calculate svm/rf matrix
true_countL = vector(mode = "list", length = simulation_times) # list contains the count table of each true cluster
seurat_countL = vector(mode = "list", length = simulation_times) # list contains the count table of each cluster defined by seurat
knn_matrixL = vector(mode = "list", length = simulation_times) # list contains the knn matrix getting from each simulation
true_matrixL = vector(mode = "list", length = simulation_times) # list contains the true similarity matrix getting from each simulation
rf_matrixL = vector(mode = "list", length = simulation_times) # list contains the knn matrix getting from each simulation
svm_matrixL = vector(mode = "list", length = simulation_times) # list contains the true similarity matrix getting from each simulation

set.seed(123)
#for (sim in 1:10){
for (sim in 11:simulation_times){
  print(sim)
  timeL = rep(NA, 8) # DCATS w/wto similarity matrix, fisher, speckle, diffcyt, scDC
  ## simulation
  simulation = simulator_propM(totalV = sample(sample_size1:sample_size2, nrow(prop_mat)), prop_mat, setresolu, sim_mat)
  if (is.na(simulation)[1] == FALSE){
    true_countL[[sim]] = simulation$numb_sim
    
    ## data convert
    numb_cond = simulation$dfRes %>% 
      group_by(clusterRes, batch) %>% 
      summarise(n = n()) %>% 
      pivot_wider(names_from = "clusterRes", values_from = "n") %>% 
      mutate(batch = str_remove(batch, "rep") %>% as.numeric()) %>% 
      arrange(batch) %>% 
      column_to_rownames(var = "batch")
    numb_cond[is.na(numb_cond)] <- 0
    conf.mat <- table(simulation$trueLabels, Idents(simulation$integratedSamples))
    true.conf <- conf.mat/rowSums(conf.mat)
    library(clue)
    order2 = as.vector(solve_LSAP(true.conf, maximum = TRUE))
    L_sum = colSums(numb_cond)
    decider = sum(L_sum > nrow(prop_mat))
    if (decider == cluster_num) {   # if one cluster has least than 10 cells in one condition, then won't continue
      seurat_countL[[sim]] = numb_cond[,order2]
      
      ## Get matrices
      ### KNN matrix
      graphs = simulation$integratedSamples@graphs$RNA_snn
      labels = Idents(simulation$integratedSamples)
      knn_mat = knn_simMat(graphs, labels)
      order1 = colnames(numb_cond)
      simil_matK = knn_mat[order1, order1]
      knn_matrixL[[sim]] = simil_matK
      ### True matrix
      simil_matT = true.conf[,order2]
      true_matrixL[[sim]] = simil_matT
      ### Uniform matrix
      simil_matU = create_simMat(cluster_num, confuse_rate=0.1)
      ### svm&rf
      mlDF = simulation$integratedSamples@reductions$pca@cell.embeddings %>% 
        as.data.frame() %>% 
        tibble::rownames_to_column("cellID") %>% 
        merge(simulation$dfRes, by = "cellID") %>% 
        dplyr::select(-cellID)
      set.seed(123)
      simil_matSVM = svm_simMat(mlDF)
      svm_matrixL[[sim]] = simil_matSVM
      
      ## Test
      ### DCATS---betabinLRT
      sim_count = numb_cond %>% as.matrix()
      sim_design = design_mat
      t1start = Sys.time()
      betabin_null = dcats_GLM(sim_count, sim_design, base_model = "FULL")
      timeL[1] = Sys.time() - t1start
      ###  DCATS---betabinLRT with Bias correction from similarity matrix
      phi = getPhi(sim_count, sim_design)
      avrgPhi = getPhi2(sim_count, sim_design)$avrgPhi
      adjPhi = getPhi2(sim_count, sim_design)$adjPhiV
      estPhi_null = dcats_GLM(sim_count, sim_design, phi = rep(phi, cluster_num), base_model = "FULL")
      avrgPhi_null = dcats_GLM(sim_count, sim_design, phi = rep(avrgPhi, cluster_num), base_model = "FULL")
      adjPhi_null = dcats_GLM(sim_count, sim_design, phi = adjPhi, base_model = "FULL")
      ## KNN
      sim_countBC = sim_count
      for (i in seq_len(nrow(sim_count))) {
        sim_countBC[i, ] <- sum(sim_count[i, ]) * multinom_EM(sim_count[i, ], simil_matK, verbose = FALSE)$mu
        sim_countBC[i, ] = ceiling(sim_countBC[i, ])}
      wtoPhi_emK = dcats_GLM(sim_countBC, sim_design, base_model = "FULL")
      estPhi_emK = dcats_GLM(sim_countBC, sim_design, phi = rep(phi, cluster_num), base_model = "FULL")
      avrgPhi_emK = dcats_GLM(sim_countBC, sim_design, phi = rep(avrgPhi, cluster_num), base_model = "FULL")
      adjPhi_emK = dcats_GLM(sim_countBC, sim_design, phi = adjPhi, base_model = "FULL")
      ## Uniform
      sim_countBC = sim_count
      for (i in seq_len(nrow(sim_count))) {
        sim_countBC[i, ] <- sum(sim_count[i, ]) * multinom_EM(sim_count[i, ], simil_matU, verbose = FALSE)$mu
        sim_countBC[i, ] = ceiling(sim_countBC[i, ])}
      wtoPhi_emU = dcats_GLM(sim_countBC, sim_design, base_model = "FULL")
      estPhi_emU = dcats_GLM(sim_countBC, sim_design, phi = rep(phi, cluster_num), base_model = "FULL")
      avrgPhi_emU = dcats_GLM(sim_countBC, sim_design, phi = rep(avrgPhi, cluster_num), base_model = "FULL")
      adjPhi_emU = dcats_GLM(sim_countBC, sim_design, phi = adjPhi, base_model = "FULL")
      ## True
      sim_countBC = sim_count
      for (i in seq_len(nrow(sim_count))) {
        sim_countBC[i, ] <- sum(sim_count[i, ]) * multinom_EM(sim_count[i, ], simil_matT, verbose = FALSE)$mu
        sim_countBC[i, ] = ceiling(sim_countBC[i, ])}
      wtoPhi_emT = dcats_GLM(sim_countBC, sim_design, base_model = "FULL")
      estPhi_emT = dcats_GLM(sim_countBC, sim_design, phi = rep(phi, cluster_num), base_model = "FULL")
      avrgPhi_emT = dcats_GLM(sim_countBC, sim_design, phi = rep(avrgPhi, cluster_num), base_model = "FULL")
      adjPhi_emT = dcats_GLM(sim_countBC, sim_design, phi = adjPhi, base_model = "FULL")
      ## svm
      sim_countBC = sim_count
      for (i in seq_len(nrow(sim_count))) {
        sim_countBC[i, ] <- sum(sim_count[i, ]) * multinom_EM(sim_count[i, ], simil_matSVM, verbose = FALSE)$mu
        sim_countBC[i, ] = ceiling(sim_countBC[i, ])}
      wtoPhi_emSVM = dcats_GLM(sim_countBC, sim_design, base_model = "FULL")
      estPhi_emSVM = dcats_GLM(sim_countBC, sim_design, phi = rep(phi, cluster_num), base_model = "FULL")
      avrgPhi_emSVM = dcats_GLM(sim_countBC, sim_design, phi = rep(avrgPhi, cluster_num), base_model = "FULL")
      adjPhi_emSVM = dcats_GLM(sim_countBC, sim_design, phi = adjPhi, base_model = "FULL")
      
      ## Fisher's exact test
      numb_cond1 = numb_cond[which(design_mat$condition == 'cond1'),]
      numb_cond2 = numb_cond[which(design_mat$condition == 'cond2'),]
      t3start = Sys.time()
      fisher_pvals = getFisher(as.matrix(numb_cond1), as.matrix(numb_cond2))
      timeL[3] = Sys.time() - t3start
      ## speckle
      t4start = Sys.time()
      speckleDF = simulation$dfRes %>% 
        mutate(group = ifelse(batch %in% str_c("rep", as.character(1:10)), "cond1", "cond2"))
      speckleRes = propeller(clusters = simulation$dfRes$clusterRes, sample = simulation$dfRes$batch, group = speckleDF$group) %>% 
        dplyr::rename(cluster = BaselineProp.clusters,
                      speckle_pvals = FDR) %>%
        dplyr::select(cluster, speckle_pvals)
      timeL[4] = Sys.time() - t4start
      ## diffcyt
      t5start = Sys.time()
      diffcytP = getDiffcyt(numb_cond1, numb_cond2, simulation$dfRes)
      timeL[5] = Sys.time() - t5start
      ## scDC
      t6start = Sys.time()
      res_scDC <- scDC_noClustering(cellTypes = simulation$dfRes$clusterRes, simulation$dfRes$batch, calCI = TRUE, calCI_method = c("percentile", "BCa", "multinom"),nboot = 1000, verbose = FALSE)
      res_GLM <- fitGLM(res_scDC, c(rep("cond1",10*cluster_num),rep("cond2",10*cluster_num)), pairwise = FALSE, fixed_only = TRUE, verbose = FALSE)
      timeL[6] = Sys.time() - t6start
      scDCRes_temp = summary(res_GLM$pool_res_fixed)
      scDCRes = scDCRes_temp[c(cluster_num+1,(dim(scDCRes_temp)[1]-cluster_num+2):dim(scDCRes_temp)[1]),]
      
      ## results
      cluster_map = data.frame(cluster = colnames(numb_cond1[,order2]), truth = truthRes) %>% 
        arrange(cluster)
      all_res = cluster_map %>% 
        mutate(betabin_null_pvals = as.vector(betabin_null$LRT_pvals[,1]),
               estPhi_null_pvals = as.vector(estPhi_null$LRT_pvals[,1]),
               avrgPhi_null_pvals = as.vector(avrgPhi_null$LRT_pvals[,1]),
               adjPhi_null_pavls = as.vector(adjPhi_null$LRT_pvals[,1]),
               wtoPhi_emSVM_pvals = as.vector(wtoPhi_emSVM$LRT_pvals[,1]),
               estPhi_emSVM_pvals = as.vector(estPhi_emSVM$LRT_pvals[,1]),
               avrgPhi_emSVM_pvals = as.vector(avrgPhi_emSVM$LRT_pvals[,1]),
               adjPhi_emSVM_pvals = as.vector(adjPhi_emSVM$LRT_pvals[,1]),
               wtoPhi_emT_pvals = as.vector(wtoPhi_emT$LRT_pvals[,1]),
               estPhi_emT_pvals = as.vector(estPhi_emT$LRT_pvals[,1]),
               avrgPhi_emT_pvals = as.vector(avrgPhi_emT$LRT_pvals[,1]),
               adjPhi_emT_pvals = as.vector(adjPhi_emT$LRT_pvals[,1]),
               wtoPhi_emU_pvals = as.vector(wtoPhi_emU$LRT_pvals[,1]),
               estPhi_emU_pvals = as.vector(estPhi_emU$LRT_pvals[,1]),
               avrgPhi_emU_pvals = as.vector(avrgPhi_emU$LRT_pvals[,1]),
               adjPhi_emU_pvals = as.vector(adjPhi_emU$LRT_pvals[,1]),
               wtoPhi_emK_pvals = as.vector(wtoPhi_emK$LRT_pvals[,1]),
               estPhi_emK_pvals = as.vector(estPhi_emK$LRT_pvals[,1]),
               avrgPhi_emK_pvals = as.vector(avrgPhi_emK$LRT_pvals[,1]),
               adjPhi_emK_pvals = as.vector(adjPhi_emK$LRT_pvals[,1]),
               fisher_pvals = fisher_pvals,
               scDC_pvals = scDCRes$p.value) %>%
        merge(speckleRes, by = "cluster") %>% 
        merge(diffcytP, by = "cluster")
      simulationDF = rbind(simulationDF, all_res)
      
      res_gender = data.frame(cluster = colnames(numb_cond1[,order2]), truth = rep(c("P", "P", "N", "N"), 2)) %>%
        arrange(cluster) %>% 
        mutate(betabin_null_pvals = as.vector(betabin_null$LRT_pvals[,2]),
               estPhi_null_pvals = as.vector(estPhi_null$LRT_pvals[,2]),
               avrgPhi_null_pvals = as.vector(avrgPhi_null$LRT_pvals[,2]),
               adjPhi_null_pavls = as.vector(adjPhi_null$LRT_pvals[,2]),
               wtoPhi_emSVM_pvals = as.vector(wtoPhi_emSVM$LRT_pvals[,2]),
               estPhi_emSVM_pvals = as.vector(estPhi_emSVM$LRT_pvals[,2]),
               avrgPhi_emSVM_pvals = as.vector(avrgPhi_emSVM$LRT_pvals[,2]),
               adjPhi_emSVM_pvals = as.vector(adjPhi_emSVM$LRT_pvals[,2]),
               wtoPhi_emT_pvals = as.vector(wtoPhi_emT$LRT_pvals[,2]),
               estPhi_emT_pvals = as.vector(estPhi_emT$LRT_pvals[,2]),
               avrgPhi_emT_pvals = as.vector(avrgPhi_emT$LRT_pvals[,2]),
               adjPhi_emT_pvals = as.vector(adjPhi_emT$LRT_pvals[,2]),
               wtoPhi_emU_pvals = as.vector(wtoPhi_emU$LRT_pvals[,2]),
               estPhi_emU_pvals = as.vector(estPhi_emU$LRT_pvals[,2]),
               avrgPhi_emU_pvals = as.vector(avrgPhi_emU$LRT_pvals[,2]),
               adjPhi_emU_pvals = as.vector(adjPhi_emU$LRT_pvals[,2]),
               wtoPhi_emK_pvals = as.vector(wtoPhi_emK$LRT_pvals[,2]),
               estPhi_emK_pvals = as.vector(estPhi_emK$LRT_pvals[,2]),
               avrgPhi_emK_pvals = as.vector(avrgPhi_emK$LRT_pvals[,2]),
               adjPhi_emK_pvals = as.vector(adjPhi_emK$LRT_pvals[,2]))
      simulationDF_gender = rbind(simulationDF_gender, res_gender)
      
      res_age = data.frame(cluster = colnames(numb_cond1[,order2]), truth = c("P", "N", "N", "P", "P", "N", "N", "P")) %>%
        arrange(cluster) %>% 
        mutate(betabin_null_pvals = as.vector(betabin_null$LRT_pvals[,3]),
               estPhi_null_pvals = as.vector(estPhi_null$LRT_pvals[,3]),
               avrgPhi_null_pvals = as.vector(avrgPhi_null$LRT_pvals[,3]),
               adjPhi_null_pavls = as.vector(adjPhi_null$LRT_pvals[,3]),
               wtoPhi_emSVM_pvals = as.vector(wtoPhi_emSVM$LRT_pvals[,3]),
               estPhi_emSVM_pvals = as.vector(estPhi_emSVM$LRT_pvals[,3]),
               avrgPhi_emSVM_pvals = as.vector(avrgPhi_emSVM$LRT_pvals[,3]),
               adjPhi_emSVM_pvals = as.vector(adjPhi_emSVM$LRT_pvals[,3]),
               wtoPhi_emT_pvals = as.vector(wtoPhi_emT$LRT_pvals[,3]),
               estPhi_emT_pvals = as.vector(estPhi_emT$LRT_pvals[,3]),
               avrgPhi_emT_pvals = as.vector(avrgPhi_emT$LRT_pvals[,3]),
               adjPhi_emT_pvals = as.vector(adjPhi_emT$LRT_pvals[,3]),
               wtoPhi_emU_pvals = as.vector(wtoPhi_emU$LRT_pvals[,3]),
               estPhi_emU_pvals = as.vector(estPhi_emU$LRT_pvals[,3]),
               avrgPhi_emU_pvals = as.vector(avrgPhi_emU$LRT_pvals[,3]),
               adjPhi_emU_pvals = as.vector(adjPhi_emU$LRT_pvals[,3]),
               wtoPhi_emK_pvals = as.vector(wtoPhi_emK$LRT_pvals[,3]),
               estPhi_emK_pvals = as.vector(estPhi_emK$LRT_pvals[,3]),
               avrgPhi_emK_pvals = as.vector(avrgPhi_emK$LRT_pvals[,3]),
               adjPhi_emK_pvals = as.vector(adjPhi_emK$LRT_pvals[,2]))
      simulationDF_age = rbind(simulationDF_age, res_age)
      time[sim,] = timeL
    }
  }
}
```

```{r}
#file_name = str_c("D:/Data/DCATS/simulation/replicates", as.character(rep1), "&", as.character(rep2), "_K", as.character(cluster_num), "_con", as.character(concentration), "_", cell_pool, more_negative, sample_size1, "&", sample_size2, "_test.RData")
file_name = str_c("D:/Data/DCATS/simulation/replicates10&10_K", as.character(cluster_num), "_con", as.character(concentration), "_", cell_pool, more_negative, sample_size1, "&", sample_size2, "_covariate.RData")
colnames(time) = c("DCATS_wtoM", "DCATS_wM", "fisher", "speckle", "diffcyt", "scDC", "rfM", "svmM")
save(simulationDF, simulationDF_age, simulationDF_gender, time, true_countL, seurat_countL, knn_matrixL, true_matrixL, file = file_name)
head(simulationDF, 15)
```

```{r}
load(file_name)
simulationDF = simulationDF %>% na.omit()
methods = colnames(simulationDF)[3:dim(simulationDF)[2]] %>% str_remove("_pvals")
numb_mthd = length(methods)
mcc = rep(NA, numb_mthd)
auc = rep(NA, numb_mthd)
prauc = rep(NA, numb_mthd)
sensitivity = rep(NA, numb_mthd)
specificity = rep(NA, numb_mthd)
precision = rep(NA, numb_mthd)
truth = simulationDF$truth
for (i in 3:dim(simulationDF)[2]){
  auc[i-2] = getROC(simulationDF$truth, simulationDF[,i])$auc
  pred = simulationDF[, i]
  pred_res = ifelse(pred < 0.05, "P", "N")
  TP <- sum(pred_res=="P"&truth=="P")
  TN <- sum(pred_res=="N"&truth=="N")
  FP <- sum(pred_res=="P"&truth=="N")
  FN <- sum(pred_res=="N"&truth=="P")
  truthN = TN + FP
  truthP = FN + TP
  predP = TP + FP
  predN = FN + TN
  mcc[i-2] = (TP*TN-FP*FN)/sqrt(predP*truthP*truthN*predN)
  prauc[i-2] = getPRC(simulationDF$truth, simulationDF[,i])$prauc
  sensitivity[i-2] = TP/truthP
  specificity[i-2] = TN/truthN
  precision[i-2] = TP/predP
}
res = data.frame(methods = methods, mcc = mcc, auc = auc, prauc = prauc, sensitivity = sensitivity, specificity = specificity, precision = precision) %>% 
  arrange(desc(auc)) %>% 
  #filter(methods == "wtoPhi_fullK" | methods == "diffcyt" | methods == "speckle" | methods == "fisher" | methods == "scDC")
print(res)
```









